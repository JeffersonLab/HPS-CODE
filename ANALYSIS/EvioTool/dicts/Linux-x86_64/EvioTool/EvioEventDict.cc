//
// File generated by /u/site/12gev_phys/1.2/Linux_CentOS6.5-x86_64-gcc4.4.7/root/5.34.21/root/bin/rootcint at Thu Apr 30 19:32:05 2015

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME dictsdILinuxmIx86_64dIEvioTooldIEvioEventDict
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "EvioEventDict.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"

// Direct notice to TROOT of the dictionary's loading.
namespace {
   static struct DictInit {
      DictInit() {
         ROOT::RegisterModule();
      }
   } __TheDictionaryInitializer;
}

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::FADC_chan_f13_t FADC_chan_f13_t;
      #else
      class FADC_chan_f13_t  {
         public:
         //friend XX;
         int chan; //
         vector< unsigned short > samples; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::FADC_chan_f15_t FADC_chan_f15_t;
      #else
      class FADC_chan_f15_t  {
         public:
         //friend XX;
         int chan; //
         vector< short > time; //
         vector< int > adc; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::FADC_chan_f21_t FADC_chan_f21_t;
      #else
      class FADC_chan_f21_t  {
         public:
         //friend XX;
         int chan; //
         vector< short > time; //
         vector< int > adc; //
         vector< short > min; //
         vector< short > max; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::FADC_data_f13_t FADC_data_f13_t;
      #else
      class FADC_data_f13_t  {
         public:
         //friend XX;
         int crate; //
         int slot; //
         int trig; //
         int time; //
         vector< ::FADC_chan_f13_t > data; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::FADC_data_f15_t FADC_data_f15_t;
      #else
      class FADC_data_f15_t  {
         public:
         //friend XX;
         int crate; //
         int slot; //
         int trig; //
         int time; //
         vector< ::FADC_chan_f15_t > data; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::FADC_data_f21_t FADC_data_f21_t;
      #else
      class FADC_data_f21_t  {
         public:
         //friend XX;
         int crate; //
         int slot; //
         int trig; //
         int time; //
         vector< ::FADC_chan_f21_t > data; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::SVT_chan_t SVT_chan_t;
      #else
      class SVT_chan_t  {
         public:
         //friend XX;
         int fpga; //
         int chan; //
         int apv; //
         int hybrid; //
         int samples[6]; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::SVT_FPGA_t SVT_FPGA_t;
      #else
      class SVT_FPGA_t  {
         public:
         //friend XX;
         int fpga; //
         int trigger; //
         unsigned int temps[7]; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::SSP_cluster_t SSP_cluster_t;
      #else
      class SSP_cluster_t  {
         public:
         //friend XX;
         int n; //
         int e; //
         int x; //
         int y; //
         int t; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::SSP_single_t SSP_single_t;
      #else
      class SSP_single_t  {
         public:
         //friend XX;
         int i; //
         int min; //
         int max; //
         int n; //
         int t; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::SSP_pair_t SSP_pair_t;
      #else
      class SSP_pair_t  {
         public:
         //friend XX;
         int i; //
         int sum; //
         int diff; //
         int slop; //
         int cop; //
         int t; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::SSP_t SSP_t;
      #else
      class SSP_t  {
         public:
         //friend XX;
         vector< ::SSP_cluster_t > clusters; //
         vector< ::SSP_single_t > singles; //
         vector< ::SSP_pair_t > pairs; //
         int ttL; //
         int ttH; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::EVIO_Event_t EVIO_Event_t;
      #else
      class EVIO_Event_t  {
         public:
         //friend XX;
         unsigned int run_number; //
         unsigned int start_time; //
         unsigned int file_number; //
         unsigned int topnode_tag; //
         unsigned int event_number; //
         unsigned int event_type; //
         unsigned int ntrig; //
         unsigned int trigger; //
         unsigned int or_bits; //
         unsigned int top_bits; //
         unsigned int bottom_bits; //
         unsigned int pair_bits; //
         G__uint64 trig_time; //
         G__uint64 trig_timeL; //
         G__uint64 trig_timeH; //
         vector< ::FADC_data_f13_t > FADC_13; //Mode 13 - Nsamples.
         vector< ::FADC_data_f15_t > FADC_15; //Mode 15 - Integrated.
         vector< ::FADC_data_f21_t > FADC_21; //Mode 7 - High Resolution.
         ::SVT_FPGA_t SVT[7]; //SVT Crate data
         vector< ::SVT_chan_t > SVT_data; //
         ::SSP_t SSP_data; //
      };
      #endif

   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace ROOT {
   void FADC_chan_f13_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void FADC_chan_f13_t_Dictionary();
   static void *new_FADC_chan_f13_t(void *p = 0);
   static void *newArray_FADC_chan_f13_t(Long_t size, void *p);
   static void delete_FADC_chan_f13_t(void *p);
   static void deleteArray_FADC_chan_f13_t(void *p);
   static void destruct_FADC_chan_f13_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FADC_chan_f13_t*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::FADC_chan_f13_t) == sizeof(::ROOT::Shadow::FADC_chan_f13_t));
      ::FADC_chan_f13_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::FADC_chan_f13_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("FADC_chan_f13_t", "./EvioTool/EvioEvent.h", 33,
                  typeid(::FADC_chan_f13_t), DefineBehavior(ptr, ptr),
                  &FADC_chan_f13_t_ShowMembers, &FADC_chan_f13_t_Dictionary, isa_proxy, 4,
                  sizeof(::FADC_chan_f13_t) );
      instance.SetNew(&new_FADC_chan_f13_t);
      instance.SetNewArray(&newArray_FADC_chan_f13_t);
      instance.SetDelete(&delete_FADC_chan_f13_t);
      instance.SetDeleteArray(&deleteArray_FADC_chan_f13_t);
      instance.SetDestructor(&destruct_FADC_chan_f13_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FADC_chan_f13_t*)
   {
      return GenerateInitInstanceLocal((::FADC_chan_f13_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::FADC_chan_f13_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void FADC_chan_f13_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::FADC_chan_f13_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void FADC_chan_f15_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void FADC_chan_f15_t_Dictionary();
   static void *new_FADC_chan_f15_t(void *p = 0);
   static void *newArray_FADC_chan_f15_t(Long_t size, void *p);
   static void delete_FADC_chan_f15_t(void *p);
   static void deleteArray_FADC_chan_f15_t(void *p);
   static void destruct_FADC_chan_f15_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FADC_chan_f15_t*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::FADC_chan_f15_t) == sizeof(::ROOT::Shadow::FADC_chan_f15_t));
      ::FADC_chan_f15_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::FADC_chan_f15_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("FADC_chan_f15_t", "./EvioTool/EvioEvent.h", 38,
                  typeid(::FADC_chan_f15_t), DefineBehavior(ptr, ptr),
                  &FADC_chan_f15_t_ShowMembers, &FADC_chan_f15_t_Dictionary, isa_proxy, 4,
                  sizeof(::FADC_chan_f15_t) );
      instance.SetNew(&new_FADC_chan_f15_t);
      instance.SetNewArray(&newArray_FADC_chan_f15_t);
      instance.SetDelete(&delete_FADC_chan_f15_t);
      instance.SetDeleteArray(&deleteArray_FADC_chan_f15_t);
      instance.SetDestructor(&destruct_FADC_chan_f15_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FADC_chan_f15_t*)
   {
      return GenerateInitInstanceLocal((::FADC_chan_f15_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::FADC_chan_f15_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void FADC_chan_f15_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::FADC_chan_f15_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void FADC_chan_f21_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void FADC_chan_f21_t_Dictionary();
   static void *new_FADC_chan_f21_t(void *p = 0);
   static void *newArray_FADC_chan_f21_t(Long_t size, void *p);
   static void delete_FADC_chan_f21_t(void *p);
   static void deleteArray_FADC_chan_f21_t(void *p);
   static void destruct_FADC_chan_f21_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FADC_chan_f21_t*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::FADC_chan_f21_t) == sizeof(::ROOT::Shadow::FADC_chan_f21_t));
      ::FADC_chan_f21_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::FADC_chan_f21_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("FADC_chan_f21_t", "./EvioTool/EvioEvent.h", 44,
                  typeid(::FADC_chan_f21_t), DefineBehavior(ptr, ptr),
                  &FADC_chan_f21_t_ShowMembers, &FADC_chan_f21_t_Dictionary, isa_proxy, 4,
                  sizeof(::FADC_chan_f21_t) );
      instance.SetNew(&new_FADC_chan_f21_t);
      instance.SetNewArray(&newArray_FADC_chan_f21_t);
      instance.SetDelete(&delete_FADC_chan_f21_t);
      instance.SetDeleteArray(&deleteArray_FADC_chan_f21_t);
      instance.SetDestructor(&destruct_FADC_chan_f21_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FADC_chan_f21_t*)
   {
      return GenerateInitInstanceLocal((::FADC_chan_f21_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::FADC_chan_f21_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void FADC_chan_f21_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::FADC_chan_f21_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void FADC_data_f13_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void FADC_data_f13_t_Dictionary();
   static void *new_FADC_data_f13_t(void *p = 0);
   static void *newArray_FADC_data_f13_t(Long_t size, void *p);
   static void delete_FADC_data_f13_t(void *p);
   static void deleteArray_FADC_data_f13_t(void *p);
   static void destruct_FADC_data_f13_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FADC_data_f13_t*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::FADC_data_f13_t) == sizeof(::ROOT::Shadow::FADC_data_f13_t));
      ::FADC_data_f13_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::FADC_data_f13_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("FADC_data_f13_t", "./EvioTool/EvioEvent.h", 61,
                  typeid(::FADC_data_f13_t), DefineBehavior(ptr, ptr),
                  &FADC_data_f13_t_ShowMembers, &FADC_data_f13_t_Dictionary, isa_proxy, 4,
                  sizeof(::FADC_data_f13_t) );
      instance.SetNew(&new_FADC_data_f13_t);
      instance.SetNewArray(&newArray_FADC_data_f13_t);
      instance.SetDelete(&delete_FADC_data_f13_t);
      instance.SetDeleteArray(&deleteArray_FADC_data_f13_t);
      instance.SetDestructor(&destruct_FADC_data_f13_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FADC_data_f13_t*)
   {
      return GenerateInitInstanceLocal((::FADC_data_f13_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::FADC_data_f13_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void FADC_data_f13_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::FADC_data_f13_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void FADC_data_f15_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void FADC_data_f15_t_Dictionary();
   static void *new_FADC_data_f15_t(void *p = 0);
   static void *newArray_FADC_data_f15_t(Long_t size, void *p);
   static void delete_FADC_data_f15_t(void *p);
   static void deleteArray_FADC_data_f15_t(void *p);
   static void destruct_FADC_data_f15_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FADC_data_f15_t*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::FADC_data_f15_t) == sizeof(::ROOT::Shadow::FADC_data_f15_t));
      ::FADC_data_f15_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::FADC_data_f15_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("FADC_data_f15_t", "./EvioTool/EvioEvent.h", 69,
                  typeid(::FADC_data_f15_t), DefineBehavior(ptr, ptr),
                  &FADC_data_f15_t_ShowMembers, &FADC_data_f15_t_Dictionary, isa_proxy, 4,
                  sizeof(::FADC_data_f15_t) );
      instance.SetNew(&new_FADC_data_f15_t);
      instance.SetNewArray(&newArray_FADC_data_f15_t);
      instance.SetDelete(&delete_FADC_data_f15_t);
      instance.SetDeleteArray(&deleteArray_FADC_data_f15_t);
      instance.SetDestructor(&destruct_FADC_data_f15_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FADC_data_f15_t*)
   {
      return GenerateInitInstanceLocal((::FADC_data_f15_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::FADC_data_f15_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void FADC_data_f15_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::FADC_data_f15_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void FADC_data_f21_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void FADC_data_f21_t_Dictionary();
   static void *new_FADC_data_f21_t(void *p = 0);
   static void *newArray_FADC_data_f21_t(Long_t size, void *p);
   static void delete_FADC_data_f21_t(void *p);
   static void deleteArray_FADC_data_f21_t(void *p);
   static void destruct_FADC_data_f21_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FADC_data_f21_t*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::FADC_data_f21_t) == sizeof(::ROOT::Shadow::FADC_data_f21_t));
      ::FADC_data_f21_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::FADC_data_f21_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("FADC_data_f21_t", "./EvioTool/EvioEvent.h", 77,
                  typeid(::FADC_data_f21_t), DefineBehavior(ptr, ptr),
                  &FADC_data_f21_t_ShowMembers, &FADC_data_f21_t_Dictionary, isa_proxy, 4,
                  sizeof(::FADC_data_f21_t) );
      instance.SetNew(&new_FADC_data_f21_t);
      instance.SetNewArray(&newArray_FADC_data_f21_t);
      instance.SetDelete(&delete_FADC_data_f21_t);
      instance.SetDeleteArray(&deleteArray_FADC_data_f21_t);
      instance.SetDestructor(&destruct_FADC_data_f21_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FADC_data_f21_t*)
   {
      return GenerateInitInstanceLocal((::FADC_data_f21_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::FADC_data_f21_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void FADC_data_f21_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::FADC_data_f21_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void SVT_chan_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SVT_chan_t_Dictionary();
   static void *new_SVT_chan_t(void *p = 0);
   static void *newArray_SVT_chan_t(Long_t size, void *p);
   static void delete_SVT_chan_t(void *p);
   static void deleteArray_SVT_chan_t(void *p);
   static void destruct_SVT_chan_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SVT_chan_t*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::SVT_chan_t) == sizeof(::ROOT::Shadow::SVT_chan_t));
      ::SVT_chan_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SVT_chan_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SVT_chan_t", "./EvioTool/EvioEvent.h", 91,
                  typeid(::SVT_chan_t), DefineBehavior(ptr, ptr),
                  &SVT_chan_t_ShowMembers, &SVT_chan_t_Dictionary, isa_proxy, 4,
                  sizeof(::SVT_chan_t) );
      instance.SetNew(&new_SVT_chan_t);
      instance.SetNewArray(&newArray_SVT_chan_t);
      instance.SetDelete(&delete_SVT_chan_t);
      instance.SetDeleteArray(&deleteArray_SVT_chan_t);
      instance.SetDestructor(&destruct_SVT_chan_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SVT_chan_t*)
   {
      return GenerateInitInstanceLocal((::SVT_chan_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SVT_chan_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SVT_chan_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::SVT_chan_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void SVT_FPGA_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SVT_FPGA_t_Dictionary();
   static void *new_SVT_FPGA_t(void *p = 0);
   static void *newArray_SVT_FPGA_t(Long_t size, void *p);
   static void delete_SVT_FPGA_t(void *p);
   static void deleteArray_SVT_FPGA_t(void *p);
   static void destruct_SVT_FPGA_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SVT_FPGA_t*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::SVT_FPGA_t) == sizeof(::ROOT::Shadow::SVT_FPGA_t));
      ::SVT_FPGA_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SVT_FPGA_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SVT_FPGA_t", "./EvioTool/EvioEvent.h", 100,
                  typeid(::SVT_FPGA_t), DefineBehavior(ptr, ptr),
                  &SVT_FPGA_t_ShowMembers, &SVT_FPGA_t_Dictionary, isa_proxy, 4,
                  sizeof(::SVT_FPGA_t) );
      instance.SetNew(&new_SVT_FPGA_t);
      instance.SetNewArray(&newArray_SVT_FPGA_t);
      instance.SetDelete(&delete_SVT_FPGA_t);
      instance.SetDeleteArray(&deleteArray_SVT_FPGA_t);
      instance.SetDestructor(&destruct_SVT_FPGA_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SVT_FPGA_t*)
   {
      return GenerateInitInstanceLocal((::SVT_FPGA_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SVT_FPGA_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SVT_FPGA_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::SVT_FPGA_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void SSP_cluster_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SSP_cluster_t_Dictionary();
   static void *new_SSP_cluster_t(void *p = 0);
   static void *newArray_SSP_cluster_t(Long_t size, void *p);
   static void delete_SSP_cluster_t(void *p);
   static void deleteArray_SSP_cluster_t(void *p);
   static void destruct_SSP_cluster_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SSP_cluster_t*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::SSP_cluster_t) == sizeof(::ROOT::Shadow::SSP_cluster_t));
      ::SSP_cluster_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SSP_cluster_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SSP_cluster_t", "./EvioTool/EvioEvent.h", 109,
                  typeid(::SSP_cluster_t), DefineBehavior(ptr, ptr),
                  &SSP_cluster_t_ShowMembers, &SSP_cluster_t_Dictionary, isa_proxy, 4,
                  sizeof(::SSP_cluster_t) );
      instance.SetNew(&new_SSP_cluster_t);
      instance.SetNewArray(&newArray_SSP_cluster_t);
      instance.SetDelete(&delete_SSP_cluster_t);
      instance.SetDeleteArray(&deleteArray_SSP_cluster_t);
      instance.SetDestructor(&destruct_SSP_cluster_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SSP_cluster_t*)
   {
      return GenerateInitInstanceLocal((::SSP_cluster_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SSP_cluster_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SSP_cluster_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::SSP_cluster_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void SSP_single_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SSP_single_t_Dictionary();
   static void *new_SSP_single_t(void *p = 0);
   static void *newArray_SSP_single_t(Long_t size, void *p);
   static void delete_SSP_single_t(void *p);
   static void deleteArray_SSP_single_t(void *p);
   static void destruct_SSP_single_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SSP_single_t*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::SSP_single_t) == sizeof(::ROOT::Shadow::SSP_single_t));
      ::SSP_single_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SSP_single_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SSP_single_t", "./EvioTool/EvioEvent.h", 110,
                  typeid(::SSP_single_t), DefineBehavior(ptr, ptr),
                  &SSP_single_t_ShowMembers, &SSP_single_t_Dictionary, isa_proxy, 4,
                  sizeof(::SSP_single_t) );
      instance.SetNew(&new_SSP_single_t);
      instance.SetNewArray(&newArray_SSP_single_t);
      instance.SetDelete(&delete_SSP_single_t);
      instance.SetDeleteArray(&deleteArray_SSP_single_t);
      instance.SetDestructor(&destruct_SSP_single_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SSP_single_t*)
   {
      return GenerateInitInstanceLocal((::SSP_single_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SSP_single_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SSP_single_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::SSP_single_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void SSP_pair_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SSP_pair_t_Dictionary();
   static void *new_SSP_pair_t(void *p = 0);
   static void *newArray_SSP_pair_t(Long_t size, void *p);
   static void delete_SSP_pair_t(void *p);
   static void deleteArray_SSP_pair_t(void *p);
   static void destruct_SSP_pair_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SSP_pair_t*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::SSP_pair_t) == sizeof(::ROOT::Shadow::SSP_pair_t));
      ::SSP_pair_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SSP_pair_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SSP_pair_t", "./EvioTool/EvioEvent.h", 111,
                  typeid(::SSP_pair_t), DefineBehavior(ptr, ptr),
                  &SSP_pair_t_ShowMembers, &SSP_pair_t_Dictionary, isa_proxy, 4,
                  sizeof(::SSP_pair_t) );
      instance.SetNew(&new_SSP_pair_t);
      instance.SetNewArray(&newArray_SSP_pair_t);
      instance.SetDelete(&delete_SSP_pair_t);
      instance.SetDeleteArray(&deleteArray_SSP_pair_t);
      instance.SetDestructor(&destruct_SSP_pair_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SSP_pair_t*)
   {
      return GenerateInitInstanceLocal((::SSP_pair_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SSP_pair_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SSP_pair_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::SSP_pair_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void SSP_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SSP_t_Dictionary();
   static void *new_SSP_t(void *p = 0);
   static void *newArray_SSP_t(Long_t size, void *p);
   static void delete_SSP_t(void *p);
   static void deleteArray_SSP_t(void *p);
   static void destruct_SSP_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SSP_t*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::SSP_t) == sizeof(::ROOT::Shadow::SSP_t));
      ::SSP_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SSP_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SSP_t", "./EvioTool/EvioEvent.h", 112,
                  typeid(::SSP_t), DefineBehavior(ptr, ptr),
                  &SSP_t_ShowMembers, &SSP_t_Dictionary, isa_proxy, 4,
                  sizeof(::SSP_t) );
      instance.SetNew(&new_SSP_t);
      instance.SetNewArray(&newArray_SSP_t);
      instance.SetDelete(&delete_SSP_t);
      instance.SetDeleteArray(&deleteArray_SSP_t);
      instance.SetDestructor(&destruct_SSP_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SSP_t*)
   {
      return GenerateInitInstanceLocal((::SSP_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SSP_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SSP_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::SSP_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void EVIO_Event_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void EVIO_Event_t_Dictionary();
   static void *new_EVIO_Event_t(void *p = 0);
   static void *newArray_EVIO_Event_t(Long_t size, void *p);
   static void delete_EVIO_Event_t(void *p);
   static void deleteArray_EVIO_Event_t(void *p);
   static void destruct_EVIO_Event_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::EVIO_Event_t*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::EVIO_Event_t) == sizeof(::ROOT::Shadow::EVIO_Event_t));
      ::EVIO_Event_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::EVIO_Event_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("EVIO_Event_t", "./EvioTool/EvioEvent.h", 118,
                  typeid(::EVIO_Event_t), DefineBehavior(ptr, ptr),
                  &EVIO_Event_t_ShowMembers, &EVIO_Event_t_Dictionary, isa_proxy, 4,
                  sizeof(::EVIO_Event_t) );
      instance.SetNew(&new_EVIO_Event_t);
      instance.SetNewArray(&newArray_EVIO_Event_t);
      instance.SetDelete(&delete_EVIO_Event_t);
      instance.SetDeleteArray(&deleteArray_EVIO_Event_t);
      instance.SetDestructor(&destruct_EVIO_Event_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::EVIO_Event_t*)
   {
      return GenerateInitInstanceLocal((::EVIO_Event_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::EVIO_Event_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void EVIO_Event_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::EVIO_Event_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

//______________________________________________________________________________
namespace ROOT {
   void FADC_chan_f13_t_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class FADC_chan_f13_t.
      typedef ::ROOT::Shadow::FADC_chan_f13_t ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::FADC_chan_f13_t*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "chan", &sobj->chan);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "samples", (void*)&sobj->samples);
      R__insp.InspectMember("vector<unsigned short>", (void*)&sobj->samples, "samples.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FADC_chan_f13_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FADC_chan_f13_t : new ::FADC_chan_f13_t;
   }
   static void *newArray_FADC_chan_f13_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FADC_chan_f13_t[nElements] : new ::FADC_chan_f13_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_FADC_chan_f13_t(void *p) {
      delete ((::FADC_chan_f13_t*)p);
   }
   static void deleteArray_FADC_chan_f13_t(void *p) {
      delete [] ((::FADC_chan_f13_t*)p);
   }
   static void destruct_FADC_chan_f13_t(void *p) {
      typedef ::FADC_chan_f13_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::FADC_chan_f13_t

//______________________________________________________________________________
namespace ROOT {
   void FADC_chan_f15_t_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class FADC_chan_f15_t.
      typedef ::ROOT::Shadow::FADC_chan_f15_t ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::FADC_chan_f15_t*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "chan", &sobj->chan);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "time", (void*)&sobj->time);
      R__insp.InspectMember("vector<short>", (void*)&sobj->time, "time.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "adc", (void*)&sobj->adc);
      R__insp.InspectMember("vector<int>", (void*)&sobj->adc, "adc.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FADC_chan_f15_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FADC_chan_f15_t : new ::FADC_chan_f15_t;
   }
   static void *newArray_FADC_chan_f15_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FADC_chan_f15_t[nElements] : new ::FADC_chan_f15_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_FADC_chan_f15_t(void *p) {
      delete ((::FADC_chan_f15_t*)p);
   }
   static void deleteArray_FADC_chan_f15_t(void *p) {
      delete [] ((::FADC_chan_f15_t*)p);
   }
   static void destruct_FADC_chan_f15_t(void *p) {
      typedef ::FADC_chan_f15_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::FADC_chan_f15_t

//______________________________________________________________________________
namespace ROOT {
   void FADC_chan_f21_t_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class FADC_chan_f21_t.
      typedef ::ROOT::Shadow::FADC_chan_f21_t ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::FADC_chan_f21_t*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "chan", &sobj->chan);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "time", (void*)&sobj->time);
      R__insp.InspectMember("vector<short>", (void*)&sobj->time, "time.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "adc", (void*)&sobj->adc);
      R__insp.InspectMember("vector<int>", (void*)&sobj->adc, "adc.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "min", (void*)&sobj->min);
      R__insp.InspectMember("vector<short>", (void*)&sobj->min, "min.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "max", (void*)&sobj->max);
      R__insp.InspectMember("vector<short>", (void*)&sobj->max, "max.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FADC_chan_f21_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FADC_chan_f21_t : new ::FADC_chan_f21_t;
   }
   static void *newArray_FADC_chan_f21_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FADC_chan_f21_t[nElements] : new ::FADC_chan_f21_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_FADC_chan_f21_t(void *p) {
      delete ((::FADC_chan_f21_t*)p);
   }
   static void deleteArray_FADC_chan_f21_t(void *p) {
      delete [] ((::FADC_chan_f21_t*)p);
   }
   static void destruct_FADC_chan_f21_t(void *p) {
      typedef ::FADC_chan_f21_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::FADC_chan_f21_t

//______________________________________________________________________________
namespace ROOT {
   void FADC_data_f13_t_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class FADC_data_f13_t.
      typedef ::ROOT::Shadow::FADC_data_f13_t ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::FADC_data_f13_t*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "crate", &sobj->crate);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "slot", &sobj->slot);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "trig", &sobj->trig);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "time", &sobj->time);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "data", (void*)&sobj->data);
      R__insp.InspectMember("vector<FADC_chan_f13_t>", (void*)&sobj->data, "data.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FADC_data_f13_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FADC_data_f13_t : new ::FADC_data_f13_t;
   }
   static void *newArray_FADC_data_f13_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FADC_data_f13_t[nElements] : new ::FADC_data_f13_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_FADC_data_f13_t(void *p) {
      delete ((::FADC_data_f13_t*)p);
   }
   static void deleteArray_FADC_data_f13_t(void *p) {
      delete [] ((::FADC_data_f13_t*)p);
   }
   static void destruct_FADC_data_f13_t(void *p) {
      typedef ::FADC_data_f13_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::FADC_data_f13_t

//______________________________________________________________________________
namespace ROOT {
   void FADC_data_f15_t_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class FADC_data_f15_t.
      typedef ::ROOT::Shadow::FADC_data_f15_t ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::FADC_data_f15_t*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "crate", &sobj->crate);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "slot", &sobj->slot);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "trig", &sobj->trig);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "time", &sobj->time);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "data", (void*)&sobj->data);
      R__insp.InspectMember("vector<FADC_chan_f15_t>", (void*)&sobj->data, "data.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FADC_data_f15_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FADC_data_f15_t : new ::FADC_data_f15_t;
   }
   static void *newArray_FADC_data_f15_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FADC_data_f15_t[nElements] : new ::FADC_data_f15_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_FADC_data_f15_t(void *p) {
      delete ((::FADC_data_f15_t*)p);
   }
   static void deleteArray_FADC_data_f15_t(void *p) {
      delete [] ((::FADC_data_f15_t*)p);
   }
   static void destruct_FADC_data_f15_t(void *p) {
      typedef ::FADC_data_f15_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::FADC_data_f15_t

//______________________________________________________________________________
namespace ROOT {
   void FADC_data_f21_t_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class FADC_data_f21_t.
      typedef ::ROOT::Shadow::FADC_data_f21_t ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::FADC_data_f21_t*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "crate", &sobj->crate);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "slot", &sobj->slot);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "trig", &sobj->trig);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "time", &sobj->time);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "data", (void*)&sobj->data);
      R__insp.InspectMember("vector<FADC_chan_f21_t>", (void*)&sobj->data, "data.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FADC_data_f21_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FADC_data_f21_t : new ::FADC_data_f21_t;
   }
   static void *newArray_FADC_data_f21_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FADC_data_f21_t[nElements] : new ::FADC_data_f21_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_FADC_data_f21_t(void *p) {
      delete ((::FADC_data_f21_t*)p);
   }
   static void deleteArray_FADC_data_f21_t(void *p) {
      delete [] ((::FADC_data_f21_t*)p);
   }
   static void destruct_FADC_data_f21_t(void *p) {
      typedef ::FADC_data_f21_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::FADC_data_f21_t

//______________________________________________________________________________
namespace ROOT {
   void SVT_chan_t_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class SVT_chan_t.
      typedef ::ROOT::Shadow::SVT_chan_t ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::SVT_chan_t*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fpga", &sobj->fpga);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "chan", &sobj->chan);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "apv", &sobj->apv);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "hybrid", &sobj->hybrid);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "samples[6]", sobj->samples);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_SVT_chan_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SVT_chan_t : new ::SVT_chan_t;
   }
   static void *newArray_SVT_chan_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SVT_chan_t[nElements] : new ::SVT_chan_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SVT_chan_t(void *p) {
      delete ((::SVT_chan_t*)p);
   }
   static void deleteArray_SVT_chan_t(void *p) {
      delete [] ((::SVT_chan_t*)p);
   }
   static void destruct_SVT_chan_t(void *p) {
      typedef ::SVT_chan_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SVT_chan_t

//______________________________________________________________________________
namespace ROOT {
   void SVT_FPGA_t_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class SVT_FPGA_t.
      typedef ::ROOT::Shadow::SVT_FPGA_t ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::SVT_FPGA_t*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fpga", &sobj->fpga);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "trigger", &sobj->trigger);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "temps[7]", sobj->temps);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_SVT_FPGA_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SVT_FPGA_t : new ::SVT_FPGA_t;
   }
   static void *newArray_SVT_FPGA_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SVT_FPGA_t[nElements] : new ::SVT_FPGA_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SVT_FPGA_t(void *p) {
      delete ((::SVT_FPGA_t*)p);
   }
   static void deleteArray_SVT_FPGA_t(void *p) {
      delete [] ((::SVT_FPGA_t*)p);
   }
   static void destruct_SVT_FPGA_t(void *p) {
      typedef ::SVT_FPGA_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SVT_FPGA_t

//______________________________________________________________________________
namespace ROOT {
   void SSP_cluster_t_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class SSP_cluster_t.
      typedef ::ROOT::Shadow::SSP_cluster_t ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::SSP_cluster_t*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "n", &sobj->n);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "e", &sobj->e);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "x", &sobj->x);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "y", &sobj->y);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "t", &sobj->t);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_SSP_cluster_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SSP_cluster_t : new ::SSP_cluster_t;
   }
   static void *newArray_SSP_cluster_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SSP_cluster_t[nElements] : new ::SSP_cluster_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SSP_cluster_t(void *p) {
      delete ((::SSP_cluster_t*)p);
   }
   static void deleteArray_SSP_cluster_t(void *p) {
      delete [] ((::SSP_cluster_t*)p);
   }
   static void destruct_SSP_cluster_t(void *p) {
      typedef ::SSP_cluster_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SSP_cluster_t

//______________________________________________________________________________
namespace ROOT {
   void SSP_single_t_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class SSP_single_t.
      typedef ::ROOT::Shadow::SSP_single_t ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::SSP_single_t*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "i", &sobj->i);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "min", &sobj->min);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "max", &sobj->max);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "n", &sobj->n);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "t", &sobj->t);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_SSP_single_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SSP_single_t : new ::SSP_single_t;
   }
   static void *newArray_SSP_single_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SSP_single_t[nElements] : new ::SSP_single_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SSP_single_t(void *p) {
      delete ((::SSP_single_t*)p);
   }
   static void deleteArray_SSP_single_t(void *p) {
      delete [] ((::SSP_single_t*)p);
   }
   static void destruct_SSP_single_t(void *p) {
      typedef ::SSP_single_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SSP_single_t

//______________________________________________________________________________
namespace ROOT {
   void SSP_pair_t_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class SSP_pair_t.
      typedef ::ROOT::Shadow::SSP_pair_t ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::SSP_pair_t*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "i", &sobj->i);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "sum", &sobj->sum);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "diff", &sobj->diff);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "slop", &sobj->slop);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cop", &sobj->cop);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "t", &sobj->t);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_SSP_pair_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SSP_pair_t : new ::SSP_pair_t;
   }
   static void *newArray_SSP_pair_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SSP_pair_t[nElements] : new ::SSP_pair_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SSP_pair_t(void *p) {
      delete ((::SSP_pair_t*)p);
   }
   static void deleteArray_SSP_pair_t(void *p) {
      delete [] ((::SSP_pair_t*)p);
   }
   static void destruct_SSP_pair_t(void *p) {
      typedef ::SSP_pair_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SSP_pair_t

//______________________________________________________________________________
namespace ROOT {
   void SSP_t_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class SSP_t.
      typedef ::ROOT::Shadow::SSP_t ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::SSP_t*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "clusters", (void*)&sobj->clusters);
      R__insp.InspectMember("vector<SSP_cluster_t>", (void*)&sobj->clusters, "clusters.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "singles", (void*)&sobj->singles);
      R__insp.InspectMember("vector<SSP_single_t>", (void*)&sobj->singles, "singles.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "pairs", (void*)&sobj->pairs);
      R__insp.InspectMember("vector<SSP_pair_t>", (void*)&sobj->pairs, "pairs.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ttL", &sobj->ttL);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ttH", &sobj->ttH);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_SSP_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SSP_t : new ::SSP_t;
   }
   static void *newArray_SSP_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SSP_t[nElements] : new ::SSP_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SSP_t(void *p) {
      delete ((::SSP_t*)p);
   }
   static void deleteArray_SSP_t(void *p) {
      delete [] ((::SSP_t*)p);
   }
   static void destruct_SSP_t(void *p) {
      typedef ::SSP_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SSP_t

//______________________________________________________________________________
namespace ROOT {
   void EVIO_Event_t_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class EVIO_Event_t.
      typedef ::ROOT::Shadow::EVIO_Event_t ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::EVIO_Event_t*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "run_number", &sobj->run_number);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "start_time", &sobj->start_time);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "file_number", &sobj->file_number);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "topnode_tag", &sobj->topnode_tag);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "event_number", &sobj->event_number);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "event_type", &sobj->event_type);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ntrig", &sobj->ntrig);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "trigger", &sobj->trigger);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "or_bits", &sobj->or_bits);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "top_bits", &sobj->top_bits);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "bottom_bits", &sobj->bottom_bits);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "pair_bits", &sobj->pair_bits);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "trig_time", &sobj->trig_time);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "trig_timeL", &sobj->trig_timeL);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "trig_timeH", &sobj->trig_timeH);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "FADC_13", (void*)&sobj->FADC_13);
      R__insp.InspectMember("vector<FADC_data_f13_t>", (void*)&sobj->FADC_13, "FADC_13.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "FADC_15", (void*)&sobj->FADC_15);
      R__insp.InspectMember("vector<FADC_data_f15_t>", (void*)&sobj->FADC_15, "FADC_15.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "FADC_21", (void*)&sobj->FADC_21);
      R__insp.InspectMember("vector<FADC_data_f21_t>", (void*)&sobj->FADC_21, "FADC_21.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SVT[7]", sobj->SVT);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SVT_data", (void*)&sobj->SVT_data);
      R__insp.InspectMember("vector<SVT_chan_t>", (void*)&sobj->SVT_data, "SVT_data.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SSP_data", (void*)&sobj->SSP_data);
      R__insp.InspectMember("SSP_t", (void*)&sobj->SSP_data, "SSP_data.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_EVIO_Event_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EVIO_Event_t : new ::EVIO_Event_t;
   }
   static void *newArray_EVIO_Event_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EVIO_Event_t[nElements] : new ::EVIO_Event_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_EVIO_Event_t(void *p) {
      delete ((::EVIO_Event_t*)p);
   }
   static void deleteArray_EVIO_Event_t(void *p) {
      delete [] ((::EVIO_Event_t*)p);
   }
   static void destruct_EVIO_Event_t(void *p) {
      typedef ::EVIO_Event_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::EVIO_Event_t

namespace ROOT {
   void vectorlEFADC_chan_f13_tgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEFADC_chan_f13_tgR_Dictionary();
   static void *new_vectorlEFADC_chan_f13_tgR(void *p = 0);
   static void *newArray_vectorlEFADC_chan_f13_tgR(Long_t size, void *p);
   static void delete_vectorlEFADC_chan_f13_tgR(void *p);
   static void deleteArray_vectorlEFADC_chan_f13_tgR(void *p);
   static void destruct_vectorlEFADC_chan_f13_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<FADC_chan_f13_t>*)
   {
      vector<FADC_chan_f13_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<FADC_chan_f13_t>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<FADC_chan_f13_t>", -2, "/u/site/12gev_phys/1.2/Linux_CentOS6.5-x86_64-gcc4.4.7/root/5.34.21/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<FADC_chan_f13_t>), DefineBehavior(ptr, ptr),
                  0, &vectorlEFADC_chan_f13_tgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<FADC_chan_f13_t>) );
      instance.SetNew(&new_vectorlEFADC_chan_f13_tgR);
      instance.SetNewArray(&newArray_vectorlEFADC_chan_f13_tgR);
      instance.SetDelete(&delete_vectorlEFADC_chan_f13_tgR);
      instance.SetDeleteArray(&deleteArray_vectorlEFADC_chan_f13_tgR);
      instance.SetDestructor(&destruct_vectorlEFADC_chan_f13_tgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<FADC_chan_f13_t> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<FADC_chan_f13_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEFADC_chan_f13_tgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<FADC_chan_f13_t>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEFADC_chan_f13_tgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<FADC_chan_f13_t> : new vector<FADC_chan_f13_t>;
   }
   static void *newArray_vectorlEFADC_chan_f13_tgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<FADC_chan_f13_t>[nElements] : new vector<FADC_chan_f13_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEFADC_chan_f13_tgR(void *p) {
      delete ((vector<FADC_chan_f13_t>*)p);
   }
   static void deleteArray_vectorlEFADC_chan_f13_tgR(void *p) {
      delete [] ((vector<FADC_chan_f13_t>*)p);
   }
   static void destruct_vectorlEFADC_chan_f13_tgR(void *p) {
      typedef vector<FADC_chan_f13_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<FADC_chan_f13_t>

namespace ROOT {
   void vectorlEFADC_chan_f15_tgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEFADC_chan_f15_tgR_Dictionary();
   static void *new_vectorlEFADC_chan_f15_tgR(void *p = 0);
   static void *newArray_vectorlEFADC_chan_f15_tgR(Long_t size, void *p);
   static void delete_vectorlEFADC_chan_f15_tgR(void *p);
   static void deleteArray_vectorlEFADC_chan_f15_tgR(void *p);
   static void destruct_vectorlEFADC_chan_f15_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<FADC_chan_f15_t>*)
   {
      vector<FADC_chan_f15_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<FADC_chan_f15_t>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<FADC_chan_f15_t>", -2, "/u/site/12gev_phys/1.2/Linux_CentOS6.5-x86_64-gcc4.4.7/root/5.34.21/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<FADC_chan_f15_t>), DefineBehavior(ptr, ptr),
                  0, &vectorlEFADC_chan_f15_tgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<FADC_chan_f15_t>) );
      instance.SetNew(&new_vectorlEFADC_chan_f15_tgR);
      instance.SetNewArray(&newArray_vectorlEFADC_chan_f15_tgR);
      instance.SetDelete(&delete_vectorlEFADC_chan_f15_tgR);
      instance.SetDeleteArray(&deleteArray_vectorlEFADC_chan_f15_tgR);
      instance.SetDestructor(&destruct_vectorlEFADC_chan_f15_tgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<FADC_chan_f15_t> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<FADC_chan_f15_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEFADC_chan_f15_tgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<FADC_chan_f15_t>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEFADC_chan_f15_tgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<FADC_chan_f15_t> : new vector<FADC_chan_f15_t>;
   }
   static void *newArray_vectorlEFADC_chan_f15_tgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<FADC_chan_f15_t>[nElements] : new vector<FADC_chan_f15_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEFADC_chan_f15_tgR(void *p) {
      delete ((vector<FADC_chan_f15_t>*)p);
   }
   static void deleteArray_vectorlEFADC_chan_f15_tgR(void *p) {
      delete [] ((vector<FADC_chan_f15_t>*)p);
   }
   static void destruct_vectorlEFADC_chan_f15_tgR(void *p) {
      typedef vector<FADC_chan_f15_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<FADC_chan_f15_t>

namespace ROOT {
   void vectorlEFADC_chan_f21_tgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEFADC_chan_f21_tgR_Dictionary();
   static void *new_vectorlEFADC_chan_f21_tgR(void *p = 0);
   static void *newArray_vectorlEFADC_chan_f21_tgR(Long_t size, void *p);
   static void delete_vectorlEFADC_chan_f21_tgR(void *p);
   static void deleteArray_vectorlEFADC_chan_f21_tgR(void *p);
   static void destruct_vectorlEFADC_chan_f21_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<FADC_chan_f21_t>*)
   {
      vector<FADC_chan_f21_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<FADC_chan_f21_t>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<FADC_chan_f21_t>", -2, "/u/site/12gev_phys/1.2/Linux_CentOS6.5-x86_64-gcc4.4.7/root/5.34.21/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<FADC_chan_f21_t>), DefineBehavior(ptr, ptr),
                  0, &vectorlEFADC_chan_f21_tgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<FADC_chan_f21_t>) );
      instance.SetNew(&new_vectorlEFADC_chan_f21_tgR);
      instance.SetNewArray(&newArray_vectorlEFADC_chan_f21_tgR);
      instance.SetDelete(&delete_vectorlEFADC_chan_f21_tgR);
      instance.SetDeleteArray(&deleteArray_vectorlEFADC_chan_f21_tgR);
      instance.SetDestructor(&destruct_vectorlEFADC_chan_f21_tgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<FADC_chan_f21_t> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<FADC_chan_f21_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEFADC_chan_f21_tgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<FADC_chan_f21_t>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEFADC_chan_f21_tgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<FADC_chan_f21_t> : new vector<FADC_chan_f21_t>;
   }
   static void *newArray_vectorlEFADC_chan_f21_tgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<FADC_chan_f21_t>[nElements] : new vector<FADC_chan_f21_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEFADC_chan_f21_tgR(void *p) {
      delete ((vector<FADC_chan_f21_t>*)p);
   }
   static void deleteArray_vectorlEFADC_chan_f21_tgR(void *p) {
      delete [] ((vector<FADC_chan_f21_t>*)p);
   }
   static void destruct_vectorlEFADC_chan_f21_tgR(void *p) {
      typedef vector<FADC_chan_f21_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<FADC_chan_f21_t>

namespace ROOT {
   void vectorlEFADC_data_f13_tgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEFADC_data_f13_tgR_Dictionary();
   static void *new_vectorlEFADC_data_f13_tgR(void *p = 0);
   static void *newArray_vectorlEFADC_data_f13_tgR(Long_t size, void *p);
   static void delete_vectorlEFADC_data_f13_tgR(void *p);
   static void deleteArray_vectorlEFADC_data_f13_tgR(void *p);
   static void destruct_vectorlEFADC_data_f13_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<FADC_data_f13_t>*)
   {
      vector<FADC_data_f13_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<FADC_data_f13_t>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<FADC_data_f13_t>", -2, "/u/site/12gev_phys/1.2/Linux_CentOS6.5-x86_64-gcc4.4.7/root/5.34.21/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<FADC_data_f13_t>), DefineBehavior(ptr, ptr),
                  0, &vectorlEFADC_data_f13_tgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<FADC_data_f13_t>) );
      instance.SetNew(&new_vectorlEFADC_data_f13_tgR);
      instance.SetNewArray(&newArray_vectorlEFADC_data_f13_tgR);
      instance.SetDelete(&delete_vectorlEFADC_data_f13_tgR);
      instance.SetDeleteArray(&deleteArray_vectorlEFADC_data_f13_tgR);
      instance.SetDestructor(&destruct_vectorlEFADC_data_f13_tgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<FADC_data_f13_t> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<FADC_data_f13_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEFADC_data_f13_tgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<FADC_data_f13_t>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEFADC_data_f13_tgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<FADC_data_f13_t> : new vector<FADC_data_f13_t>;
   }
   static void *newArray_vectorlEFADC_data_f13_tgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<FADC_data_f13_t>[nElements] : new vector<FADC_data_f13_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEFADC_data_f13_tgR(void *p) {
      delete ((vector<FADC_data_f13_t>*)p);
   }
   static void deleteArray_vectorlEFADC_data_f13_tgR(void *p) {
      delete [] ((vector<FADC_data_f13_t>*)p);
   }
   static void destruct_vectorlEFADC_data_f13_tgR(void *p) {
      typedef vector<FADC_data_f13_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<FADC_data_f13_t>

namespace ROOT {
   void vectorlEFADC_data_f15_tgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEFADC_data_f15_tgR_Dictionary();
   static void *new_vectorlEFADC_data_f15_tgR(void *p = 0);
   static void *newArray_vectorlEFADC_data_f15_tgR(Long_t size, void *p);
   static void delete_vectorlEFADC_data_f15_tgR(void *p);
   static void deleteArray_vectorlEFADC_data_f15_tgR(void *p);
   static void destruct_vectorlEFADC_data_f15_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<FADC_data_f15_t>*)
   {
      vector<FADC_data_f15_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<FADC_data_f15_t>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<FADC_data_f15_t>", -2, "/u/site/12gev_phys/1.2/Linux_CentOS6.5-x86_64-gcc4.4.7/root/5.34.21/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<FADC_data_f15_t>), DefineBehavior(ptr, ptr),
                  0, &vectorlEFADC_data_f15_tgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<FADC_data_f15_t>) );
      instance.SetNew(&new_vectorlEFADC_data_f15_tgR);
      instance.SetNewArray(&newArray_vectorlEFADC_data_f15_tgR);
      instance.SetDelete(&delete_vectorlEFADC_data_f15_tgR);
      instance.SetDeleteArray(&deleteArray_vectorlEFADC_data_f15_tgR);
      instance.SetDestructor(&destruct_vectorlEFADC_data_f15_tgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<FADC_data_f15_t> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<FADC_data_f15_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEFADC_data_f15_tgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<FADC_data_f15_t>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEFADC_data_f15_tgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<FADC_data_f15_t> : new vector<FADC_data_f15_t>;
   }
   static void *newArray_vectorlEFADC_data_f15_tgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<FADC_data_f15_t>[nElements] : new vector<FADC_data_f15_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEFADC_data_f15_tgR(void *p) {
      delete ((vector<FADC_data_f15_t>*)p);
   }
   static void deleteArray_vectorlEFADC_data_f15_tgR(void *p) {
      delete [] ((vector<FADC_data_f15_t>*)p);
   }
   static void destruct_vectorlEFADC_data_f15_tgR(void *p) {
      typedef vector<FADC_data_f15_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<FADC_data_f15_t>

namespace ROOT {
   void vectorlEFADC_data_f21_tgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEFADC_data_f21_tgR_Dictionary();
   static void *new_vectorlEFADC_data_f21_tgR(void *p = 0);
   static void *newArray_vectorlEFADC_data_f21_tgR(Long_t size, void *p);
   static void delete_vectorlEFADC_data_f21_tgR(void *p);
   static void deleteArray_vectorlEFADC_data_f21_tgR(void *p);
   static void destruct_vectorlEFADC_data_f21_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<FADC_data_f21_t>*)
   {
      vector<FADC_data_f21_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<FADC_data_f21_t>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<FADC_data_f21_t>", -2, "/u/site/12gev_phys/1.2/Linux_CentOS6.5-x86_64-gcc4.4.7/root/5.34.21/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<FADC_data_f21_t>), DefineBehavior(ptr, ptr),
                  0, &vectorlEFADC_data_f21_tgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<FADC_data_f21_t>) );
      instance.SetNew(&new_vectorlEFADC_data_f21_tgR);
      instance.SetNewArray(&newArray_vectorlEFADC_data_f21_tgR);
      instance.SetDelete(&delete_vectorlEFADC_data_f21_tgR);
      instance.SetDeleteArray(&deleteArray_vectorlEFADC_data_f21_tgR);
      instance.SetDestructor(&destruct_vectorlEFADC_data_f21_tgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<FADC_data_f21_t> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<FADC_data_f21_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEFADC_data_f21_tgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<FADC_data_f21_t>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEFADC_data_f21_tgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<FADC_data_f21_t> : new vector<FADC_data_f21_t>;
   }
   static void *newArray_vectorlEFADC_data_f21_tgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<FADC_data_f21_t>[nElements] : new vector<FADC_data_f21_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEFADC_data_f21_tgR(void *p) {
      delete ((vector<FADC_data_f21_t>*)p);
   }
   static void deleteArray_vectorlEFADC_data_f21_tgR(void *p) {
      delete [] ((vector<FADC_data_f21_t>*)p);
   }
   static void destruct_vectorlEFADC_data_f21_tgR(void *p) {
      typedef vector<FADC_data_f21_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<FADC_data_f21_t>

namespace ROOT {
   void vectorlESSP_cluster_tgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlESSP_cluster_tgR_Dictionary();
   static void *new_vectorlESSP_cluster_tgR(void *p = 0);
   static void *newArray_vectorlESSP_cluster_tgR(Long_t size, void *p);
   static void delete_vectorlESSP_cluster_tgR(void *p);
   static void deleteArray_vectorlESSP_cluster_tgR(void *p);
   static void destruct_vectorlESSP_cluster_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<SSP_cluster_t>*)
   {
      vector<SSP_cluster_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<SSP_cluster_t>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<SSP_cluster_t>", -2, "/u/site/12gev_phys/1.2/Linux_CentOS6.5-x86_64-gcc4.4.7/root/5.34.21/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<SSP_cluster_t>), DefineBehavior(ptr, ptr),
                  0, &vectorlESSP_cluster_tgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<SSP_cluster_t>) );
      instance.SetNew(&new_vectorlESSP_cluster_tgR);
      instance.SetNewArray(&newArray_vectorlESSP_cluster_tgR);
      instance.SetDelete(&delete_vectorlESSP_cluster_tgR);
      instance.SetDeleteArray(&deleteArray_vectorlESSP_cluster_tgR);
      instance.SetDestructor(&destruct_vectorlESSP_cluster_tgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<SSP_cluster_t> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<SSP_cluster_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlESSP_cluster_tgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<SSP_cluster_t>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlESSP_cluster_tgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<SSP_cluster_t> : new vector<SSP_cluster_t>;
   }
   static void *newArray_vectorlESSP_cluster_tgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<SSP_cluster_t>[nElements] : new vector<SSP_cluster_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlESSP_cluster_tgR(void *p) {
      delete ((vector<SSP_cluster_t>*)p);
   }
   static void deleteArray_vectorlESSP_cluster_tgR(void *p) {
      delete [] ((vector<SSP_cluster_t>*)p);
   }
   static void destruct_vectorlESSP_cluster_tgR(void *p) {
      typedef vector<SSP_cluster_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<SSP_cluster_t>

namespace ROOT {
   void vectorlESSP_pair_tgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlESSP_pair_tgR_Dictionary();
   static void *new_vectorlESSP_pair_tgR(void *p = 0);
   static void *newArray_vectorlESSP_pair_tgR(Long_t size, void *p);
   static void delete_vectorlESSP_pair_tgR(void *p);
   static void deleteArray_vectorlESSP_pair_tgR(void *p);
   static void destruct_vectorlESSP_pair_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<SSP_pair_t>*)
   {
      vector<SSP_pair_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<SSP_pair_t>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<SSP_pair_t>", -2, "/u/site/12gev_phys/1.2/Linux_CentOS6.5-x86_64-gcc4.4.7/root/5.34.21/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<SSP_pair_t>), DefineBehavior(ptr, ptr),
                  0, &vectorlESSP_pair_tgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<SSP_pair_t>) );
      instance.SetNew(&new_vectorlESSP_pair_tgR);
      instance.SetNewArray(&newArray_vectorlESSP_pair_tgR);
      instance.SetDelete(&delete_vectorlESSP_pair_tgR);
      instance.SetDeleteArray(&deleteArray_vectorlESSP_pair_tgR);
      instance.SetDestructor(&destruct_vectorlESSP_pair_tgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<SSP_pair_t> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<SSP_pair_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlESSP_pair_tgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<SSP_pair_t>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlESSP_pair_tgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<SSP_pair_t> : new vector<SSP_pair_t>;
   }
   static void *newArray_vectorlESSP_pair_tgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<SSP_pair_t>[nElements] : new vector<SSP_pair_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlESSP_pair_tgR(void *p) {
      delete ((vector<SSP_pair_t>*)p);
   }
   static void deleteArray_vectorlESSP_pair_tgR(void *p) {
      delete [] ((vector<SSP_pair_t>*)p);
   }
   static void destruct_vectorlESSP_pair_tgR(void *p) {
      typedef vector<SSP_pair_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<SSP_pair_t>

namespace ROOT {
   void vectorlESSP_single_tgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlESSP_single_tgR_Dictionary();
   static void *new_vectorlESSP_single_tgR(void *p = 0);
   static void *newArray_vectorlESSP_single_tgR(Long_t size, void *p);
   static void delete_vectorlESSP_single_tgR(void *p);
   static void deleteArray_vectorlESSP_single_tgR(void *p);
   static void destruct_vectorlESSP_single_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<SSP_single_t>*)
   {
      vector<SSP_single_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<SSP_single_t>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<SSP_single_t>", -2, "/u/site/12gev_phys/1.2/Linux_CentOS6.5-x86_64-gcc4.4.7/root/5.34.21/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<SSP_single_t>), DefineBehavior(ptr, ptr),
                  0, &vectorlESSP_single_tgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<SSP_single_t>) );
      instance.SetNew(&new_vectorlESSP_single_tgR);
      instance.SetNewArray(&newArray_vectorlESSP_single_tgR);
      instance.SetDelete(&delete_vectorlESSP_single_tgR);
      instance.SetDeleteArray(&deleteArray_vectorlESSP_single_tgR);
      instance.SetDestructor(&destruct_vectorlESSP_single_tgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<SSP_single_t> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<SSP_single_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlESSP_single_tgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<SSP_single_t>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlESSP_single_tgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<SSP_single_t> : new vector<SSP_single_t>;
   }
   static void *newArray_vectorlESSP_single_tgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<SSP_single_t>[nElements] : new vector<SSP_single_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlESSP_single_tgR(void *p) {
      delete ((vector<SSP_single_t>*)p);
   }
   static void deleteArray_vectorlESSP_single_tgR(void *p) {
      delete [] ((vector<SSP_single_t>*)p);
   }
   static void destruct_vectorlESSP_single_tgR(void *p) {
      typedef vector<SSP_single_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<SSP_single_t>

namespace ROOT {
   void vectorlESVT_chan_tgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlESVT_chan_tgR_Dictionary();
   static void *new_vectorlESVT_chan_tgR(void *p = 0);
   static void *newArray_vectorlESVT_chan_tgR(Long_t size, void *p);
   static void delete_vectorlESVT_chan_tgR(void *p);
   static void deleteArray_vectorlESVT_chan_tgR(void *p);
   static void destruct_vectorlESVT_chan_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<SVT_chan_t>*)
   {
      vector<SVT_chan_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<SVT_chan_t>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<SVT_chan_t>", -2, "/u/site/12gev_phys/1.2/Linux_CentOS6.5-x86_64-gcc4.4.7/root/5.34.21/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<SVT_chan_t>), DefineBehavior(ptr, ptr),
                  0, &vectorlESVT_chan_tgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<SVT_chan_t>) );
      instance.SetNew(&new_vectorlESVT_chan_tgR);
      instance.SetNewArray(&newArray_vectorlESVT_chan_tgR);
      instance.SetDelete(&delete_vectorlESVT_chan_tgR);
      instance.SetDeleteArray(&deleteArray_vectorlESVT_chan_tgR);
      instance.SetDestructor(&destruct_vectorlESVT_chan_tgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<SVT_chan_t> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<SVT_chan_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlESVT_chan_tgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<SVT_chan_t>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlESVT_chan_tgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<SVT_chan_t> : new vector<SVT_chan_t>;
   }
   static void *newArray_vectorlESVT_chan_tgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<SVT_chan_t>[nElements] : new vector<SVT_chan_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlESVT_chan_tgR(void *p) {
      delete ((vector<SVT_chan_t>*)p);
   }
   static void deleteArray_vectorlESVT_chan_tgR(void *p) {
      delete [] ((vector<SVT_chan_t>*)p);
   }
   static void destruct_vectorlESVT_chan_tgR(void *p) {
      typedef vector<SVT_chan_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<SVT_chan_t>

namespace ROOT {
   void vectorlEintgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEintgR_Dictionary();
   static void *new_vectorlEintgR(void *p = 0);
   static void *newArray_vectorlEintgR(Long_t size, void *p);
   static void delete_vectorlEintgR(void *p);
   static void deleteArray_vectorlEintgR(void *p);
   static void destruct_vectorlEintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<int>*)
   {
      vector<int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<int>", -2, "/u/site/12gev_phys/1.2/Linux_CentOS6.5-x86_64-gcc4.4.7/root/5.34.21/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<int>), DefineBehavior(ptr, ptr),
                  0, &vectorlEintgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<int>) );
      instance.SetNew(&new_vectorlEintgR);
      instance.SetNewArray(&newArray_vectorlEintgR);
      instance.SetDelete(&delete_vectorlEintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEintgR);
      instance.SetDestructor(&destruct_vectorlEintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<int> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<int> : new vector<int>;
   }
   static void *newArray_vectorlEintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<int>[nElements] : new vector<int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEintgR(void *p) {
      delete ((vector<int>*)p);
   }
   static void deleteArray_vectorlEintgR(void *p) {
      delete [] ((vector<int>*)p);
   }
   static void destruct_vectorlEintgR(void *p) {
      typedef vector<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<int>

namespace ROOT {
   void vectorlEshortgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEshortgR_Dictionary();
   static void *new_vectorlEshortgR(void *p = 0);
   static void *newArray_vectorlEshortgR(Long_t size, void *p);
   static void delete_vectorlEshortgR(void *p);
   static void deleteArray_vectorlEshortgR(void *p);
   static void destruct_vectorlEshortgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<short>*)
   {
      vector<short> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<short>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<short>", -2, "vector.dll", 0,
                  typeid(vector<short>), DefineBehavior(ptr, ptr),
                  0, &vectorlEshortgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<short>) );
      instance.SetNew(&new_vectorlEshortgR);
      instance.SetNewArray(&newArray_vectorlEshortgR);
      instance.SetDelete(&delete_vectorlEshortgR);
      instance.SetDeleteArray(&deleteArray_vectorlEshortgR);
      instance.SetDestructor(&destruct_vectorlEshortgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<short> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<short>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEshortgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<short>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEshortgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<short> : new vector<short>;
   }
   static void *newArray_vectorlEshortgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<short>[nElements] : new vector<short>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEshortgR(void *p) {
      delete ((vector<short>*)p);
   }
   static void deleteArray_vectorlEshortgR(void *p) {
      delete [] ((vector<short>*)p);
   }
   static void destruct_vectorlEshortgR(void *p) {
      typedef vector<short> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<short>

namespace ROOT {
   void vectorlEunsignedsPshortgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEunsignedsPshortgR_Dictionary();
   static void *new_vectorlEunsignedsPshortgR(void *p = 0);
   static void *newArray_vectorlEunsignedsPshortgR(Long_t size, void *p);
   static void delete_vectorlEunsignedsPshortgR(void *p);
   static void deleteArray_vectorlEunsignedsPshortgR(void *p);
   static void destruct_vectorlEunsignedsPshortgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<unsigned short>*)
   {
      vector<unsigned short> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<unsigned short>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<unsigned short>", -2, "vector.dll", 0,
                  typeid(vector<unsigned short>), DefineBehavior(ptr, ptr),
                  0, &vectorlEunsignedsPshortgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<unsigned short>) );
      instance.SetNew(&new_vectorlEunsignedsPshortgR);
      instance.SetNewArray(&newArray_vectorlEunsignedsPshortgR);
      instance.SetDelete(&delete_vectorlEunsignedsPshortgR);
      instance.SetDeleteArray(&deleteArray_vectorlEunsignedsPshortgR);
      instance.SetDestructor(&destruct_vectorlEunsignedsPshortgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<unsigned short> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<unsigned short>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEunsignedsPshortgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<unsigned short>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEunsignedsPshortgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<unsigned short> : new vector<unsigned short>;
   }
   static void *newArray_vectorlEunsignedsPshortgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<unsigned short>[nElements] : new vector<unsigned short>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEunsignedsPshortgR(void *p) {
      delete ((vector<unsigned short>*)p);
   }
   static void deleteArray_vectorlEunsignedsPshortgR(void *p) {
      delete [] ((vector<unsigned short>*)p);
   }
   static void destruct_vectorlEunsignedsPshortgR(void *p) {
      typedef vector<unsigned short> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<unsigned short>

/********************************************************
* dicts/Linux-x86_64/EvioTool/EvioEventDict.cc
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableEvioEventDict();

extern "C" void G__set_cpp_environmentEvioEventDict() {
  G__cpp_reset_tagtableEvioEventDict();
}
#include <new>
extern "C" int G__cpp_dllrevEvioEventDict() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* FADC_chan_f13_t */
// automatic default constructor
static int G__EvioEventDict_168_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FADC_chan_f13_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FADC_chan_f13_t[n];
     } else {
       p = new((void*) gvp) FADC_chan_f13_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FADC_chan_f13_t;
     } else {
       p = new((void*) gvp) FADC_chan_f13_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f13_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EvioEventDict_168_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   FADC_chan_f13_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new FADC_chan_f13_t(*(FADC_chan_f13_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f13_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef FADC_chan_f13_t G__TFADC_chan_f13_t;
static int G__EvioEventDict_168_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (FADC_chan_f13_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((FADC_chan_f13_t*) (soff+(sizeof(FADC_chan_f13_t)*i)))->~G__TFADC_chan_f13_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (FADC_chan_f13_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((FADC_chan_f13_t*) (soff))->~G__TFADC_chan_f13_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EvioEventDict_168_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FADC_chan_f13_t* dest = (FADC_chan_f13_t*) G__getstructoffset();
   *dest = *(FADC_chan_f13_t*) libp->para[0].ref;
   const FADC_chan_f13_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* FADC_chan_f15_t */
// automatic default constructor
static int G__EvioEventDict_169_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FADC_chan_f15_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FADC_chan_f15_t[n];
     } else {
       p = new((void*) gvp) FADC_chan_f15_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FADC_chan_f15_t;
     } else {
       p = new((void*) gvp) FADC_chan_f15_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f15_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EvioEventDict_169_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   FADC_chan_f15_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new FADC_chan_f15_t(*(FADC_chan_f15_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f15_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef FADC_chan_f15_t G__TFADC_chan_f15_t;
static int G__EvioEventDict_169_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (FADC_chan_f15_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((FADC_chan_f15_t*) (soff+(sizeof(FADC_chan_f15_t)*i)))->~G__TFADC_chan_f15_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (FADC_chan_f15_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((FADC_chan_f15_t*) (soff))->~G__TFADC_chan_f15_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EvioEventDict_169_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FADC_chan_f15_t* dest = (FADC_chan_f15_t*) G__getstructoffset();
   *dest = *(FADC_chan_f15_t*) libp->para[0].ref;
   const FADC_chan_f15_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* FADC_chan_f21_t */
static int G__EvioEventDict_174_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((FADC_chan_f21_t*) G__getstructoffset())->print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__EvioEventDict_174_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FADC_chan_f21_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FADC_chan_f21_t[n];
     } else {
       p = new((void*) gvp) FADC_chan_f21_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FADC_chan_f21_t;
     } else {
       p = new((void*) gvp) FADC_chan_f21_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f21_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EvioEventDict_174_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   FADC_chan_f21_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new FADC_chan_f21_t(*(FADC_chan_f21_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f21_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef FADC_chan_f21_t G__TFADC_chan_f21_t;
static int G__EvioEventDict_174_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (FADC_chan_f21_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((FADC_chan_f21_t*) (soff+(sizeof(FADC_chan_f21_t)*i)))->~G__TFADC_chan_f21_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (FADC_chan_f21_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((FADC_chan_f21_t*) (soff))->~G__TFADC_chan_f21_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EvioEventDict_174_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FADC_chan_f21_t* dest = (FADC_chan_f21_t*) G__getstructoffset();
   *dest = *(FADC_chan_f21_t*) libp->para[0].ref;
   const FADC_chan_f21_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* FADC_data_f13_t */
// automatic default constructor
static int G__EvioEventDict_175_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FADC_data_f13_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FADC_data_f13_t[n];
     } else {
       p = new((void*) gvp) FADC_data_f13_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FADC_data_f13_t;
     } else {
       p = new((void*) gvp) FADC_data_f13_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f13_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EvioEventDict_175_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   FADC_data_f13_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new FADC_data_f13_t(*(FADC_data_f13_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f13_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef FADC_data_f13_t G__TFADC_data_f13_t;
static int G__EvioEventDict_175_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (FADC_data_f13_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((FADC_data_f13_t*) (soff+(sizeof(FADC_data_f13_t)*i)))->~G__TFADC_data_f13_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (FADC_data_f13_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((FADC_data_f13_t*) (soff))->~G__TFADC_data_f13_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EvioEventDict_175_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FADC_data_f13_t* dest = (FADC_data_f13_t*) G__getstructoffset();
   *dest = *(FADC_data_f13_t*) libp->para[0].ref;
   const FADC_data_f13_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* FADC_data_f15_t */
// automatic default constructor
static int G__EvioEventDict_180_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FADC_data_f15_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FADC_data_f15_t[n];
     } else {
       p = new((void*) gvp) FADC_data_f15_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FADC_data_f15_t;
     } else {
       p = new((void*) gvp) FADC_data_f15_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f15_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EvioEventDict_180_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   FADC_data_f15_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new FADC_data_f15_t(*(FADC_data_f15_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f15_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef FADC_data_f15_t G__TFADC_data_f15_t;
static int G__EvioEventDict_180_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (FADC_data_f15_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((FADC_data_f15_t*) (soff+(sizeof(FADC_data_f15_t)*i)))->~G__TFADC_data_f15_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (FADC_data_f15_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((FADC_data_f15_t*) (soff))->~G__TFADC_data_f15_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EvioEventDict_180_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FADC_data_f15_t* dest = (FADC_data_f15_t*) G__getstructoffset();
   *dest = *(FADC_data_f15_t*) libp->para[0].ref;
   const FADC_data_f15_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* FADC_data_f21_t */
static int G__EvioEventDict_185_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((FADC_data_f21_t*) G__getstructoffset())->print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__EvioEventDict_185_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FADC_data_f21_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FADC_data_f21_t[n];
     } else {
       p = new((void*) gvp) FADC_data_f21_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FADC_data_f21_t;
     } else {
       p = new((void*) gvp) FADC_data_f21_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f21_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EvioEventDict_185_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   FADC_data_f21_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new FADC_data_f21_t(*(FADC_data_f21_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f21_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef FADC_data_f21_t G__TFADC_data_f21_t;
static int G__EvioEventDict_185_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (FADC_data_f21_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((FADC_data_f21_t*) (soff+(sizeof(FADC_data_f21_t)*i)))->~G__TFADC_data_f21_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (FADC_data_f21_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((FADC_data_f21_t*) (soff))->~G__TFADC_data_f21_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EvioEventDict_185_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FADC_data_f21_t* dest = (FADC_data_f21_t*) G__getstructoffset();
   *dest = *(FADC_data_f21_t*) libp->para[0].ref;
   const FADC_data_f21_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SVT_chan_t */
// automatic default constructor
static int G__EvioEventDict_190_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SVT_chan_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SVT_chan_t[n];
     } else {
       p = new((void*) gvp) SVT_chan_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SVT_chan_t;
     } else {
       p = new((void*) gvp) SVT_chan_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_SVT_chan_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EvioEventDict_190_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SVT_chan_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SVT_chan_t(*(SVT_chan_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_SVT_chan_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SVT_chan_t G__TSVT_chan_t;
static int G__EvioEventDict_190_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SVT_chan_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SVT_chan_t*) (soff+(sizeof(SVT_chan_t)*i)))->~G__TSVT_chan_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SVT_chan_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SVT_chan_t*) (soff))->~G__TSVT_chan_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EvioEventDict_190_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SVT_chan_t* dest = (SVT_chan_t*) G__getstructoffset();
   *dest = *(SVT_chan_t*) libp->para[0].ref;
   const SVT_chan_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SVT_FPGA_t */
// automatic default constructor
static int G__EvioEventDict_191_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SVT_FPGA_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SVT_FPGA_t[n];
     } else {
       p = new((void*) gvp) SVT_FPGA_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SVT_FPGA_t;
     } else {
       p = new((void*) gvp) SVT_FPGA_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_SVT_FPGA_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EvioEventDict_191_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SVT_FPGA_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SVT_FPGA_t(*(SVT_FPGA_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_SVT_FPGA_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SVT_FPGA_t G__TSVT_FPGA_t;
static int G__EvioEventDict_191_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SVT_FPGA_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SVT_FPGA_t*) (soff+(sizeof(SVT_FPGA_t)*i)))->~G__TSVT_FPGA_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SVT_FPGA_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SVT_FPGA_t*) (soff))->~G__TSVT_FPGA_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EvioEventDict_191_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SVT_FPGA_t* dest = (SVT_FPGA_t*) G__getstructoffset();
   *dest = *(SVT_FPGA_t*) libp->para[0].ref;
   const SVT_FPGA_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SSP_cluster_t */
// automatic default constructor
static int G__EvioEventDict_192_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SSP_cluster_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SSP_cluster_t[n];
     } else {
       p = new((void*) gvp) SSP_cluster_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SSP_cluster_t;
     } else {
       p = new((void*) gvp) SSP_cluster_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_SSP_cluster_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EvioEventDict_192_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SSP_cluster_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SSP_cluster_t(*(SSP_cluster_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_SSP_cluster_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SSP_cluster_t G__TSSP_cluster_t;
static int G__EvioEventDict_192_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SSP_cluster_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SSP_cluster_t*) (soff+(sizeof(SSP_cluster_t)*i)))->~G__TSSP_cluster_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SSP_cluster_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SSP_cluster_t*) (soff))->~G__TSSP_cluster_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EvioEventDict_192_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SSP_cluster_t* dest = (SSP_cluster_t*) G__getstructoffset();
   *dest = *(SSP_cluster_t*) libp->para[0].ref;
   const SSP_cluster_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SSP_single_t */
// automatic default constructor
static int G__EvioEventDict_193_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SSP_single_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SSP_single_t[n];
     } else {
       p = new((void*) gvp) SSP_single_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SSP_single_t;
     } else {
       p = new((void*) gvp) SSP_single_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_SSP_single_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EvioEventDict_193_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SSP_single_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SSP_single_t(*(SSP_single_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_SSP_single_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SSP_single_t G__TSSP_single_t;
static int G__EvioEventDict_193_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SSP_single_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SSP_single_t*) (soff+(sizeof(SSP_single_t)*i)))->~G__TSSP_single_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SSP_single_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SSP_single_t*) (soff))->~G__TSSP_single_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EvioEventDict_193_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SSP_single_t* dest = (SSP_single_t*) G__getstructoffset();
   *dest = *(SSP_single_t*) libp->para[0].ref;
   const SSP_single_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SSP_pair_t */
// automatic default constructor
static int G__EvioEventDict_194_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SSP_pair_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SSP_pair_t[n];
     } else {
       p = new((void*) gvp) SSP_pair_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SSP_pair_t;
     } else {
       p = new((void*) gvp) SSP_pair_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_SSP_pair_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EvioEventDict_194_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SSP_pair_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SSP_pair_t(*(SSP_pair_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_SSP_pair_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SSP_pair_t G__TSSP_pair_t;
static int G__EvioEventDict_194_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SSP_pair_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SSP_pair_t*) (soff+(sizeof(SSP_pair_t)*i)))->~G__TSSP_pair_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SSP_pair_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SSP_pair_t*) (soff))->~G__TSSP_pair_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EvioEventDict_194_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SSP_pair_t* dest = (SSP_pair_t*) G__getstructoffset();
   *dest = *(SSP_pair_t*) libp->para[0].ref;
   const SSP_pair_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SSP_t */
// automatic default constructor
static int G__EvioEventDict_195_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SSP_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SSP_t[n];
     } else {
       p = new((void*) gvp) SSP_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SSP_t;
     } else {
       p = new((void*) gvp) SSP_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_SSP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EvioEventDict_195_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SSP_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SSP_t(*(SSP_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_SSP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SSP_t G__TSSP_t;
static int G__EvioEventDict_195_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SSP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SSP_t*) (soff+(sizeof(SSP_t)*i)))->~G__TSSP_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SSP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SSP_t*) (soff))->~G__TSSP_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EvioEventDict_195_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SSP_t* dest = (SSP_t*) G__getstructoffset();
   *dest = *(SSP_t*) libp->para[0].ref;
   const SSP_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* EVIO_Event_t */
// automatic default constructor
static int G__EvioEventDict_208_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EVIO_Event_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EVIO_Event_t[n];
     } else {
       p = new((void*) gvp) EVIO_Event_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EVIO_Event_t;
     } else {
       p = new((void*) gvp) EVIO_Event_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_EVIO_Event_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EvioEventDict_208_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   EVIO_Event_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new EVIO_Event_t(*(EVIO_Event_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__EvioEventDictLN_EVIO_Event_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef EVIO_Event_t G__TEVIO_Event_t;
static int G__EvioEventDict_208_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (EVIO_Event_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((EVIO_Event_t*) (soff+(sizeof(EVIO_Event_t)*i)))->~G__TEVIO_Event_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (EVIO_Event_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((EVIO_Event_t*) (soff))->~G__TEVIO_Event_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EvioEventDict_208_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EVIO_Event_t* dest = (EVIO_Event_t*) G__getstructoffset();
   *dest = *(EVIO_Event_t*) libp->para[0].ref;
   const EVIO_Event_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */
static int G__EvioEventDict__0_2045(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      EvioEventClear((EVIO_Event_t*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EvioEventDict__0_2046(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      EvioEventInit((EVIO_Event_t*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EvioEventDict__0_2047(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      EvioEventPrint((EVIO_Event_t*) G__int(libp->para[0]), (int) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      EvioEventPrint((EVIO_Event_t*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}


/*********************************************************
* Member function Stub
*********************************************************/

/* FADC_chan_f13_t */

/* FADC_chan_f15_t */

/* FADC_chan_f21_t */

/* FADC_data_f13_t */

/* FADC_data_f15_t */

/* FADC_data_f21_t */

/* SVT_chan_t */

/* SVT_FPGA_t */

/* SSP_cluster_t */

/* SSP_single_t */

/* SSP_pair_t */

/* SSP_t */

/* EVIO_Event_t */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncEvioEventDict {
 public:
  G__Sizep2memfuncEvioEventDict(): p(&G__Sizep2memfuncEvioEventDict::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncEvioEventDict::*p)();
};

size_t G__get_sizep2memfuncEvioEventDict()
{
  G__Sizep2memfuncEvioEventDict a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceEvioEventDict() {

   /* Setting up class inheritance */
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableEvioEventDict() {

   /* Setting up typedef entry */
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<int>",117,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEintcOallocatorlEintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<FADC_chan_f13_t>",117,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_chan_f13_tcOallocatorlEFADC_chan_f13_tgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f13_tcOallocatorlEFADC_chan_f13_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_chan_f13_tcOallocatorlEFADC_chan_f13_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f13_tcOallocatorlEFADC_chan_f13_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_chan_f13_tcOallocatorlEFADC_chan_f13_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<FADC_chan_f15_t>",117,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_chan_f15_tcOallocatorlEFADC_chan_f15_tgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f15_tcOallocatorlEFADC_chan_f15_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_chan_f15_tcOallocatorlEFADC_chan_f15_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f15_tcOallocatorlEFADC_chan_f15_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_chan_f15_tcOallocatorlEFADC_chan_f15_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<FADC_chan_f21_t>",117,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_chan_f21_tcOallocatorlEFADC_chan_f21_tgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f21_tcOallocatorlEFADC_chan_f21_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_chan_f21_tcOallocatorlEFADC_chan_f21_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f21_tcOallocatorlEFADC_chan_f21_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_chan_f21_tcOallocatorlEFADC_chan_f21_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<SSP_cluster_t>",117,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESSP_cluster_tcOallocatorlESSP_cluster_tgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_cluster_tcOallocatorlESSP_cluster_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESSP_cluster_tcOallocatorlESSP_cluster_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_cluster_tcOallocatorlESSP_cluster_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESSP_cluster_tcOallocatorlESSP_cluster_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<SSP_single_t>",117,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESSP_single_tcOallocatorlESSP_single_tgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_single_tcOallocatorlESSP_single_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESSP_single_tcOallocatorlESSP_single_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_single_tcOallocatorlESSP_single_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESSP_single_tcOallocatorlESSP_single_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<SSP_pair_t>",117,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESSP_pair_tcOallocatorlESSP_pair_tgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_pair_tcOallocatorlESSP_pair_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESSP_pair_tcOallocatorlESSP_pair_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_pair_tcOallocatorlESSP_pair_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESSP_pair_tcOallocatorlESSP_pair_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<FADC_data_f13_t>",117,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_data_f13_tcOallocatorlEFADC_data_f13_tgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f13_tcOallocatorlEFADC_data_f13_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_data_f13_tcOallocatorlEFADC_data_f13_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f13_tcOallocatorlEFADC_data_f13_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_data_f13_tcOallocatorlEFADC_data_f13_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<FADC_data_f15_t>",117,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_data_f15_tcOallocatorlEFADC_data_f15_tgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f15_tcOallocatorlEFADC_data_f15_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_data_f15_tcOallocatorlEFADC_data_f15_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f15_tcOallocatorlEFADC_data_f15_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_data_f15_tcOallocatorlEFADC_data_f15_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<FADC_data_f21_t>",117,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_data_f21_tcOallocatorlEFADC_data_f21_tgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f21_tcOallocatorlEFADC_data_f21_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_data_f21_tcOallocatorlEFADC_data_f21_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f21_tcOallocatorlEFADC_data_f21_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_data_f21_tcOallocatorlEFADC_data_f21_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<SVT_chan_t>",117,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESVT_chan_tcOallocatorlESVT_chan_tgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlESVT_chan_tcOallocatorlESVT_chan_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESVT_chan_tcOallocatorlESVT_chan_tgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EvioEventDictLN_reverse_iteratorlEvectorlESVT_chan_tcOallocatorlESVT_chan_tgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESVT_chan_tcOallocatorlESVT_chan_tgRsPgR));
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* FADC_chan_f13_t */
static void G__setup_memvarFADC_chan_f13_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f13_t));
   { FADC_chan_f13_t *p; p=(FADC_chan_f13_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->chan)-(long)(p)),105,0,0,-1,-1,-1,1,"chan=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->samples)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR),G__defined_typename("vector<unsigned short>"),-1,1,"samples=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* FADC_chan_f15_t */
static void G__setup_memvarFADC_chan_f15_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f15_t));
   { FADC_chan_f15_t *p; p=(FADC_chan_f15_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->chan)-(long)(p)),105,0,0,-1,-1,-1,1,"chan=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->time)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEshortcOallocatorlEshortgRsPgR),G__defined_typename("vector<short>"),-1,1,"time=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->adc)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEintcOallocatorlEintgRsPgR),G__defined_typename("vector<int>"),-1,1,"adc=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* FADC_chan_f21_t */
static void G__setup_memvarFADC_chan_f21_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f21_t));
   { FADC_chan_f21_t *p; p=(FADC_chan_f21_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->chan)-(long)(p)),105,0,0,-1,-1,-1,1,"chan=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->time)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEshortcOallocatorlEshortgRsPgR),G__defined_typename("vector<short>"),-1,1,"time=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->adc)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEintcOallocatorlEintgRsPgR),G__defined_typename("vector<int>"),-1,1,"adc=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->min)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEshortcOallocatorlEshortgRsPgR),G__defined_typename("vector<short>"),-1,1,"min=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->max)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEshortcOallocatorlEshortgRsPgR),G__defined_typename("vector<short>"),-1,1,"max=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* FADC_data_f13_t */
static void G__setup_memvarFADC_data_f13_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f13_t));
   { FADC_data_f13_t *p; p=(FADC_data_f13_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->crate)-(long)(p)),105,0,0,-1,-1,-1,1,"crate=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->slot)-(long)(p)),105,0,0,-1,-1,-1,1,"slot=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->trig)-(long)(p)),105,0,0,-1,-1,-1,1,"trig=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->time)-(long)(p)),105,0,0,-1,-1,-1,1,"time=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->data)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_chan_f13_tcOallocatorlEFADC_chan_f13_tgRsPgR),G__defined_typename("vector<FADC_chan_f13_t>"),-1,1,"data=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* FADC_data_f15_t */
static void G__setup_memvarFADC_data_f15_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f15_t));
   { FADC_data_f15_t *p; p=(FADC_data_f15_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->crate)-(long)(p)),105,0,0,-1,-1,-1,1,"crate=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->slot)-(long)(p)),105,0,0,-1,-1,-1,1,"slot=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->trig)-(long)(p)),105,0,0,-1,-1,-1,1,"trig=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->time)-(long)(p)),105,0,0,-1,-1,-1,1,"time=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->data)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_chan_f15_tcOallocatorlEFADC_chan_f15_tgRsPgR),G__defined_typename("vector<FADC_chan_f15_t>"),-1,1,"data=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* FADC_data_f21_t */
static void G__setup_memvarFADC_data_f21_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f21_t));
   { FADC_data_f21_t *p; p=(FADC_data_f21_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->crate)-(long)(p)),105,0,0,-1,-1,-1,1,"crate=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->slot)-(long)(p)),105,0,0,-1,-1,-1,1,"slot=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->trig)-(long)(p)),105,0,0,-1,-1,-1,1,"trig=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->time)-(long)(p)),105,0,0,-1,-1,-1,1,"time=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->data)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_chan_f21_tcOallocatorlEFADC_chan_f21_tgRsPgR),G__defined_typename("vector<FADC_chan_f21_t>"),-1,1,"data=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* SVT_chan_t */
static void G__setup_memvarSVT_chan_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EvioEventDictLN_SVT_chan_t));
   { SVT_chan_t *p; p=(SVT_chan_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fpga)-(long)(p)),105,0,0,-1,-1,-1,1,"fpga=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->chan)-(long)(p)),105,0,0,-1,-1,-1,1,"chan=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->apv)-(long)(p)),105,0,0,-1,-1,-1,1,"apv=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->hybrid)-(long)(p)),105,0,0,-1,-1,-1,1,"hybrid=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->samples)-(long)(p)),105,0,0,-1,-1,-1,1,"samples[6]=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* SVT_FPGA_t */
static void G__setup_memvarSVT_FPGA_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EvioEventDictLN_SVT_FPGA_t));
   { SVT_FPGA_t *p; p=(SVT_FPGA_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fpga)-(long)(p)),105,0,0,-1,-1,-1,1,"fpga=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->trigger)-(long)(p)),105,0,0,-1,-1,-1,1,"trigger=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->temps)-(long)(p)),104,0,0,-1,-1,-1,1,"temps[7]=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* SSP_cluster_t */
static void G__setup_memvarSSP_cluster_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EvioEventDictLN_SSP_cluster_t));
   { SSP_cluster_t *p; p=(SSP_cluster_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->n)-(long)(p)),105,0,0,-1,-1,-1,1,"n=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->e)-(long)(p)),105,0,0,-1,-1,-1,1,"e=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),105,0,0,-1,-1,-1,1,"x=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),105,0,0,-1,-1,-1,1,"y=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->t)-(long)(p)),105,0,0,-1,-1,-1,1,"t=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* SSP_single_t */
static void G__setup_memvarSSP_single_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EvioEventDictLN_SSP_single_t));
   { SSP_single_t *p; p=(SSP_single_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->i)-(long)(p)),105,0,0,-1,-1,-1,1,"i=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->min)-(long)(p)),105,0,0,-1,-1,-1,1,"min=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->max)-(long)(p)),105,0,0,-1,-1,-1,1,"max=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->n)-(long)(p)),105,0,0,-1,-1,-1,1,"n=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->t)-(long)(p)),105,0,0,-1,-1,-1,1,"t=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* SSP_pair_t */
static void G__setup_memvarSSP_pair_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EvioEventDictLN_SSP_pair_t));
   { SSP_pair_t *p; p=(SSP_pair_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->i)-(long)(p)),105,0,0,-1,-1,-1,1,"i=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->sum)-(long)(p)),105,0,0,-1,-1,-1,1,"sum=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->diff)-(long)(p)),105,0,0,-1,-1,-1,1,"diff=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->slop)-(long)(p)),105,0,0,-1,-1,-1,1,"slop=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cop)-(long)(p)),105,0,0,-1,-1,-1,1,"cop=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->t)-(long)(p)),105,0,0,-1,-1,-1,1,"t=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* SSP_t */
static void G__setup_memvarSSP_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EvioEventDictLN_SSP_t));
   { SSP_t *p; p=(SSP_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->clusters)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESSP_cluster_tcOallocatorlESSP_cluster_tgRsPgR),G__defined_typename("vector<SSP_cluster_t>"),-1,1,"clusters=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->singles)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESSP_single_tcOallocatorlESSP_single_tgRsPgR),G__defined_typename("vector<SSP_single_t>"),-1,1,"singles=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->pairs)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESSP_pair_tcOallocatorlESSP_pair_tgRsPgR),G__defined_typename("vector<SSP_pair_t>"),-1,1,"pairs=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ttL)-(long)(p)),105,0,0,-1,-1,-1,1,"ttL=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ttH)-(long)(p)),105,0,0,-1,-1,-1,1,"ttH=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* EVIO_Event_t */
static void G__setup_memvarEVIO_Event_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EvioEventDictLN_EVIO_Event_t));
   { EVIO_Event_t *p; p=(EVIO_Event_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->run_number)-(long)(p)),104,0,0,-1,-1,-1,1,"run_number=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->start_time)-(long)(p)),104,0,0,-1,-1,-1,1,"start_time=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->file_number)-(long)(p)),104,0,0,-1,-1,-1,1,"file_number=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->topnode_tag)-(long)(p)),104,0,0,-1,-1,-1,1,"topnode_tag=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->event_number)-(long)(p)),104,0,0,-1,-1,-1,1,"event_number=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->event_type)-(long)(p)),104,0,0,-1,-1,-1,1,"event_type=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ntrig)-(long)(p)),104,0,0,-1,-1,-1,1,"ntrig=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->trigger)-(long)(p)),104,0,0,-1,-1,-1,1,"trigger=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->or_bits)-(long)(p)),104,0,0,-1,-1,-1,1,"or_bits=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->top_bits)-(long)(p)),104,0,0,-1,-1,-1,1,"top_bits=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->bottom_bits)-(long)(p)),104,0,0,-1,-1,-1,1,"bottom_bits=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->pair_bits)-(long)(p)),104,0,0,-1,-1,-1,1,"pair_bits=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->trig_time)-(long)(p)),109,0,0,-1,-1,-1,1,"trig_time=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->trig_timeL)-(long)(p)),109,0,0,-1,-1,-1,1,"trig_timeL=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->trig_timeH)-(long)(p)),109,0,0,-1,-1,-1,1,"trig_timeH=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->FADC_13)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_data_f13_tcOallocatorlEFADC_data_f13_tgRsPgR),G__defined_typename("vector<FADC_data_f13_t>"),-1,1,"FADC_13=",0,"Mode 13 - Nsamples.");
   G__memvar_setup((void*)((long)(&p->FADC_15)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_data_f15_tcOallocatorlEFADC_data_f15_tgRsPgR),G__defined_typename("vector<FADC_data_f15_t>"),-1,1,"FADC_15=",0,"Mode 15 - Integrated.");
   G__memvar_setup((void*)((long)(&p->FADC_21)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlEFADC_data_f21_tcOallocatorlEFADC_data_f21_tgRsPgR),G__defined_typename("vector<FADC_data_f21_t>"),-1,1,"FADC_21=",0,"Mode 7 - High Resolution.");
   G__memvar_setup((void*)((long)(&p->SVT)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_SVT_FPGA_t),-1,-1,1,"SVT[7]=",0,"SVT Crate data");
   G__memvar_setup((void*)((long)(&p->SVT_data)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_vectorlESVT_chan_tcOallocatorlESVT_chan_tgRsPgR),G__defined_typename("vector<SVT_chan_t>"),-1,1,"SVT_data=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SSP_data)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__EvioEventDictLN_SSP_t),-1,-1,1,"SSP_data=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarEvioEventDict() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncFADC_chan_f13_t(void) {
   /* FADC_chan_f13_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f13_t));
   // automatic default constructor
   G__memfunc_setup("FADC_chan_f13_t", 1283, G__EvioEventDict_168_0_1, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f13_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("FADC_chan_f13_t", 1283, G__EvioEventDict_168_0_2, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f13_t), -1, 0, 1, 1, 1, 0, "u 'FADC_chan_f13_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FADC_chan_f13_t", 1409, G__EvioEventDict_168_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__EvioEventDict_168_0_4, (int) ('u'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f13_t), -1, 1, 1, 1, 1, 0, "u 'FADC_chan_f13_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncFADC_chan_f15_t(void) {
   /* FADC_chan_f15_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f15_t));
   // automatic default constructor
   G__memfunc_setup("FADC_chan_f15_t", 1285, G__EvioEventDict_169_0_1, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f15_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("FADC_chan_f15_t", 1285, G__EvioEventDict_169_0_2, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f15_t), -1, 0, 1, 1, 1, 0, "u 'FADC_chan_f15_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FADC_chan_f15_t", 1411, G__EvioEventDict_169_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__EvioEventDict_169_0_4, (int) ('u'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f15_t), -1, 1, 1, 1, 1, 0, "u 'FADC_chan_f15_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncFADC_chan_f21_t(void) {
   /* FADC_chan_f21_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f21_t));
   G__memfunc_setup("print",557,G__EvioEventDict_174_0_1, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic default constructor
   G__memfunc_setup("FADC_chan_f21_t", 1282, G__EvioEventDict_174_0_2, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f21_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("FADC_chan_f21_t", 1282, G__EvioEventDict_174_0_3, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f21_t), -1, 0, 1, 1, 1, 0, "u 'FADC_chan_f21_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FADC_chan_f21_t", 1408, G__EvioEventDict_174_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__EvioEventDict_174_0_5, (int) ('u'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_chan_f21_t), -1, 1, 1, 1, 1, 0, "u 'FADC_chan_f21_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncFADC_data_f13_t(void) {
   /* FADC_data_f13_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f13_t));
   // automatic default constructor
   G__memfunc_setup("FADC_data_f13_t", 1283, G__EvioEventDict_175_0_1, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f13_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("FADC_data_f13_t", 1283, G__EvioEventDict_175_0_2, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f13_t), -1, 0, 1, 1, 1, 0, "u 'FADC_data_f13_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FADC_data_f13_t", 1409, G__EvioEventDict_175_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__EvioEventDict_175_0_4, (int) ('u'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f13_t), -1, 1, 1, 1, 1, 0, "u 'FADC_data_f13_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncFADC_data_f15_t(void) {
   /* FADC_data_f15_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f15_t));
   // automatic default constructor
   G__memfunc_setup("FADC_data_f15_t", 1285, G__EvioEventDict_180_0_1, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f15_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("FADC_data_f15_t", 1285, G__EvioEventDict_180_0_2, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f15_t), -1, 0, 1, 1, 1, 0, "u 'FADC_data_f15_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FADC_data_f15_t", 1411, G__EvioEventDict_180_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__EvioEventDict_180_0_4, (int) ('u'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f15_t), -1, 1, 1, 1, 1, 0, "u 'FADC_data_f15_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncFADC_data_f21_t(void) {
   /* FADC_data_f21_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f21_t));
   G__memfunc_setup("print",557,G__EvioEventDict_185_0_1, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic default constructor
   G__memfunc_setup("FADC_data_f21_t", 1282, G__EvioEventDict_185_0_2, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f21_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("FADC_data_f21_t", 1282, G__EvioEventDict_185_0_3, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f21_t), -1, 0, 1, 1, 1, 0, "u 'FADC_data_f21_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FADC_data_f21_t", 1408, G__EvioEventDict_185_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__EvioEventDict_185_0_5, (int) ('u'), G__get_linked_tagnum(&G__EvioEventDictLN_FADC_data_f21_t), -1, 1, 1, 1, 1, 0, "u 'FADC_data_f21_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSVT_chan_t(void) {
   /* SVT_chan_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EvioEventDictLN_SVT_chan_t));
   // automatic default constructor
   G__memfunc_setup("SVT_chan_t", 969, G__EvioEventDict_190_0_1, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_SVT_chan_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SVT_chan_t", 969, G__EvioEventDict_190_0_2, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_SVT_chan_t), -1, 0, 1, 1, 1, 0, "u 'SVT_chan_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SVT_chan_t", 1095, G__EvioEventDict_190_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__EvioEventDict_190_0_4, (int) ('u'), G__get_linked_tagnum(&G__EvioEventDictLN_SVT_chan_t), -1, 1, 1, 1, 1, 0, "u 'SVT_chan_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSVT_FPGA_t(void) {
   /* SVT_FPGA_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EvioEventDictLN_SVT_FPGA_t));
   // automatic default constructor
   G__memfunc_setup("SVT_FPGA_t", 845, G__EvioEventDict_191_0_1, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_SVT_FPGA_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SVT_FPGA_t", 845, G__EvioEventDict_191_0_2, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_SVT_FPGA_t), -1, 0, 1, 1, 1, 0, "u 'SVT_FPGA_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SVT_FPGA_t", 971, G__EvioEventDict_191_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__EvioEventDict_191_0_4, (int) ('u'), G__get_linked_tagnum(&G__EvioEventDictLN_SVT_FPGA_t), -1, 1, 1, 1, 1, 0, "u 'SVT_FPGA_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSSP_cluster_t(void) {
   /* SSP_cluster_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EvioEventDictLN_SSP_cluster_t));
   // automatic default constructor
   G__memfunc_setup("SSP_cluster_t", 1322, G__EvioEventDict_192_0_1, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_SSP_cluster_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SSP_cluster_t", 1322, G__EvioEventDict_192_0_2, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_SSP_cluster_t), -1, 0, 1, 1, 1, 0, "u 'SSP_cluster_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SSP_cluster_t", 1448, G__EvioEventDict_192_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__EvioEventDict_192_0_4, (int) ('u'), G__get_linked_tagnum(&G__EvioEventDictLN_SSP_cluster_t), -1, 1, 1, 1, 1, 0, "u 'SSP_cluster_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSSP_single_t(void) {
   /* SSP_single_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EvioEventDictLN_SSP_single_t));
   // automatic default constructor
   G__memfunc_setup("SSP_single_t", 1194, G__EvioEventDict_193_0_1, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_SSP_single_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SSP_single_t", 1194, G__EvioEventDict_193_0_2, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_SSP_single_t), -1, 0, 1, 1, 1, 0, "u 'SSP_single_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SSP_single_t", 1320, G__EvioEventDict_193_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__EvioEventDict_193_0_4, (int) ('u'), G__get_linked_tagnum(&G__EvioEventDictLN_SSP_single_t), -1, 1, 1, 1, 1, 0, "u 'SSP_single_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSSP_pair_t(void) {
   /* SSP_pair_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EvioEventDictLN_SSP_pair_t));
   // automatic default constructor
   G__memfunc_setup("SSP_pair_t", 980, G__EvioEventDict_194_0_1, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_SSP_pair_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SSP_pair_t", 980, G__EvioEventDict_194_0_2, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_SSP_pair_t), -1, 0, 1, 1, 1, 0, "u 'SSP_pair_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SSP_pair_t", 1106, G__EvioEventDict_194_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__EvioEventDict_194_0_4, (int) ('u'), G__get_linked_tagnum(&G__EvioEventDictLN_SSP_pair_t), -1, 1, 1, 1, 1, 0, "u 'SSP_pair_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSSP_t(void) {
   /* SSP_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EvioEventDictLN_SSP_t));
   // automatic default constructor
   G__memfunc_setup("SSP_t", 457, G__EvioEventDict_195_0_1, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_SSP_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SSP_t", 457, G__EvioEventDict_195_0_2, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_SSP_t), -1, 0, 1, 1, 1, 0, "u 'SSP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SSP_t", 583, G__EvioEventDict_195_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__EvioEventDict_195_0_4, (int) ('u'), G__get_linked_tagnum(&G__EvioEventDictLN_SSP_t), -1, 1, 1, 1, 1, 0, "u 'SSP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncEVIO_Event_t(void) {
   /* EVIO_Event_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EvioEventDictLN_EVIO_Event_t));
   // automatic default constructor
   G__memfunc_setup("EVIO_Event_t", 1127, G__EvioEventDict_208_0_1, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_EVIO_Event_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EVIO_Event_t", 1127, G__EvioEventDict_208_0_2, (int) ('i'), G__get_linked_tagnum(&G__EvioEventDictLN_EVIO_Event_t), -1, 0, 1, 1, 1, 0, "u 'EVIO_Event_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EVIO_Event_t", 1253, G__EvioEventDict_208_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__EvioEventDict_208_0_4, (int) ('u'), G__get_linked_tagnum(&G__EvioEventDictLN_EVIO_Event_t), -1, 1, 1, 1, 1, 0, "u 'EVIO_Event_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncEvioEventDict() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalEvioEventDict() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {
}

static void G__cpp_setup_func13() {
}

static void G__cpp_setup_func14() {
}

static void G__cpp_setup_func15() {
}

static void G__cpp_setup_func16() {
}

static void G__cpp_setup_func17() {
}

static void G__cpp_setup_func18() {
}

static void G__cpp_setup_func19() {
}

static void G__cpp_setup_func20() {
   G__memfunc_setup("EvioEventClear", 1404, G__EvioEventDict__0_2045, 121, -1, -1, 0, 1, 1, 1, 0, "U 'EVIO_Event_t' - 0 - evt", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("EvioEventInit", 1321, G__EvioEventDict__0_2046, 121, -1, -1, 0, 1, 1, 1, 0, "U 'EVIO_Event_t' - 0 - evt", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("EvioEventPrint", 1442, G__EvioEventDict__0_2047, 121, -1, -1, 0, 2, 1, 1, 0, 
"U 'EVIO_Event_t' - 0 - evt i - - 0 '0' level", (char*) NULL
, (void*) NULL, 0);

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcEvioEventDict() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
  G__cpp_setup_func13();
  G__cpp_setup_func14();
  G__cpp_setup_func15();
  G__cpp_setup_func16();
  G__cpp_setup_func17();
  G__cpp_setup_func18();
  G__cpp_setup_func19();
  G__cpp_setup_func20();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__EvioEventDictLN_vectorlEshortcOallocatorlEshortgRsPgR = { "vector<short,allocator<short> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR = { "vector<unsigned short,allocator<unsigned short> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_FADC_chan_f13_t = { "FADC_chan_f13_t" , 115 , -1 };
G__linked_taginfo G__EvioEventDictLN_FADC_chan_f15_t = { "FADC_chan_f15_t" , 115 , -1 };
G__linked_taginfo G__EvioEventDictLN_vectorlEintcOallocatorlEintgRsPgR = { "vector<int,allocator<int> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<int,allocator<int> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_FADC_chan_f21_t = { "FADC_chan_f21_t" , 115 , -1 };
G__linked_taginfo G__EvioEventDictLN_FADC_data_f13_t = { "FADC_data_f13_t" , 115 , -1 };
G__linked_taginfo G__EvioEventDictLN_vectorlEFADC_chan_f13_tcOallocatorlEFADC_chan_f13_tgRsPgR = { "vector<FADC_chan_f13_t,allocator<FADC_chan_f13_t> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f13_tcOallocatorlEFADC_chan_f13_tgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<FADC_chan_f13_t,allocator<FADC_chan_f13_t> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_FADC_data_f15_t = { "FADC_data_f15_t" , 115 , -1 };
G__linked_taginfo G__EvioEventDictLN_vectorlEFADC_chan_f15_tcOallocatorlEFADC_chan_f15_tgRsPgR = { "vector<FADC_chan_f15_t,allocator<FADC_chan_f15_t> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f15_tcOallocatorlEFADC_chan_f15_tgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<FADC_chan_f15_t,allocator<FADC_chan_f15_t> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_FADC_data_f21_t = { "FADC_data_f21_t" , 115 , -1 };
G__linked_taginfo G__EvioEventDictLN_vectorlEFADC_chan_f21_tcOallocatorlEFADC_chan_f21_tgRsPgR = { "vector<FADC_chan_f21_t,allocator<FADC_chan_f21_t> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f21_tcOallocatorlEFADC_chan_f21_tgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<FADC_chan_f21_t,allocator<FADC_chan_f21_t> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_SVT_chan_t = { "SVT_chan_t" , 115 , -1 };
G__linked_taginfo G__EvioEventDictLN_SVT_FPGA_t = { "SVT_FPGA_t" , 115 , -1 };
G__linked_taginfo G__EvioEventDictLN_SSP_cluster_t = { "SSP_cluster_t" , 115 , -1 };
G__linked_taginfo G__EvioEventDictLN_SSP_single_t = { "SSP_single_t" , 115 , -1 };
G__linked_taginfo G__EvioEventDictLN_SSP_pair_t = { "SSP_pair_t" , 115 , -1 };
G__linked_taginfo G__EvioEventDictLN_SSP_t = { "SSP_t" , 115 , -1 };
G__linked_taginfo G__EvioEventDictLN_vectorlESSP_cluster_tcOallocatorlESSP_cluster_tgRsPgR = { "vector<SSP_cluster_t,allocator<SSP_cluster_t> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_cluster_tcOallocatorlESSP_cluster_tgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<SSP_cluster_t,allocator<SSP_cluster_t> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_vectorlESSP_single_tcOallocatorlESSP_single_tgRsPgR = { "vector<SSP_single_t,allocator<SSP_single_t> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_single_tcOallocatorlESSP_single_tgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<SSP_single_t,allocator<SSP_single_t> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_vectorlESSP_pair_tcOallocatorlESSP_pair_tgRsPgR = { "vector<SSP_pair_t,allocator<SSP_pair_t> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_pair_tcOallocatorlESSP_pair_tgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<SSP_pair_t,allocator<SSP_pair_t> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_EVIO_Event_t = { "EVIO_Event_t" , 115 , -1 };
G__linked_taginfo G__EvioEventDictLN_vectorlEFADC_data_f13_tcOallocatorlEFADC_data_f13_tgRsPgR = { "vector<FADC_data_f13_t,allocator<FADC_data_f13_t> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f13_tcOallocatorlEFADC_data_f13_tgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<FADC_data_f13_t,allocator<FADC_data_f13_t> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_vectorlEFADC_data_f15_tcOallocatorlEFADC_data_f15_tgRsPgR = { "vector<FADC_data_f15_t,allocator<FADC_data_f15_t> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f15_tcOallocatorlEFADC_data_f15_tgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<FADC_data_f15_t,allocator<FADC_data_f15_t> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_vectorlEFADC_data_f21_tcOallocatorlEFADC_data_f21_tgRsPgR = { "vector<FADC_data_f21_t,allocator<FADC_data_f21_t> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f21_tcOallocatorlEFADC_data_f21_tgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<FADC_data_f21_t,allocator<FADC_data_f21_t> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_vectorlESVT_chan_tcOallocatorlESVT_chan_tgRsPgR = { "vector<SVT_chan_t,allocator<SVT_chan_t> >" , 99 , -1 };
G__linked_taginfo G__EvioEventDictLN_reverse_iteratorlEvectorlESVT_chan_tcOallocatorlESVT_chan_tgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<SVT_chan_t,allocator<SVT_chan_t> >::iterator>" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableEvioEventDict() {
  G__EvioEventDictLN_vectorlEshortcOallocatorlEshortgRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EvioEventDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EvioEventDictLN_FADC_chan_f13_t.tagnum = -1 ;
  G__EvioEventDictLN_FADC_chan_f15_t.tagnum = -1 ;
  G__EvioEventDictLN_vectorlEintcOallocatorlEintgRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EvioEventDictLN_FADC_chan_f21_t.tagnum = -1 ;
  G__EvioEventDictLN_FADC_data_f13_t.tagnum = -1 ;
  G__EvioEventDictLN_vectorlEFADC_chan_f13_tcOallocatorlEFADC_chan_f13_tgRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f13_tcOallocatorlEFADC_chan_f13_tgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EvioEventDictLN_FADC_data_f15_t.tagnum = -1 ;
  G__EvioEventDictLN_vectorlEFADC_chan_f15_tcOallocatorlEFADC_chan_f15_tgRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f15_tcOallocatorlEFADC_chan_f15_tgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EvioEventDictLN_FADC_data_f21_t.tagnum = -1 ;
  G__EvioEventDictLN_vectorlEFADC_chan_f21_tcOallocatorlEFADC_chan_f21_tgRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f21_tcOallocatorlEFADC_chan_f21_tgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EvioEventDictLN_SVT_chan_t.tagnum = -1 ;
  G__EvioEventDictLN_SVT_FPGA_t.tagnum = -1 ;
  G__EvioEventDictLN_SSP_cluster_t.tagnum = -1 ;
  G__EvioEventDictLN_SSP_single_t.tagnum = -1 ;
  G__EvioEventDictLN_SSP_pair_t.tagnum = -1 ;
  G__EvioEventDictLN_SSP_t.tagnum = -1 ;
  G__EvioEventDictLN_vectorlESSP_cluster_tcOallocatorlESSP_cluster_tgRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_cluster_tcOallocatorlESSP_cluster_tgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EvioEventDictLN_vectorlESSP_single_tcOallocatorlESSP_single_tgRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_single_tcOallocatorlESSP_single_tgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EvioEventDictLN_vectorlESSP_pair_tcOallocatorlESSP_pair_tgRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_pair_tcOallocatorlESSP_pair_tgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EvioEventDictLN_EVIO_Event_t.tagnum = -1 ;
  G__EvioEventDictLN_vectorlEFADC_data_f13_tcOallocatorlEFADC_data_f13_tgRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f13_tcOallocatorlEFADC_data_f13_tgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EvioEventDictLN_vectorlEFADC_data_f15_tcOallocatorlEFADC_data_f15_tgRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f15_tcOallocatorlEFADC_data_f15_tgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EvioEventDictLN_vectorlEFADC_data_f21_tcOallocatorlEFADC_data_f21_tgRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f21_tcOallocatorlEFADC_data_f21_tgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EvioEventDictLN_vectorlESVT_chan_tcOallocatorlESVT_chan_tgRsPgR.tagnum = -1 ;
  G__EvioEventDictLN_reverse_iteratorlEvectorlESVT_chan_tcOallocatorlESVT_chan_tgRsPgRcLcLiteratorgR.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableEvioEventDict() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlEshortcOallocatorlEshortgRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__EvioEventDictLN_FADC_chan_f13_t),sizeof(FADC_chan_f13_t),-1,262144,(char*)NULL,G__setup_memvarFADC_chan_f13_t,G__setup_memfuncFADC_chan_f13_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__EvioEventDictLN_FADC_chan_f15_t),sizeof(FADC_chan_f15_t),-1,262144,(char*)NULL,G__setup_memvarFADC_chan_f15_t,G__setup_memfuncFADC_chan_f15_t);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlEintcOallocatorlEintgRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__EvioEventDictLN_FADC_chan_f21_t),sizeof(FADC_chan_f21_t),-1,262144,(char*)NULL,G__setup_memvarFADC_chan_f21_t,G__setup_memfuncFADC_chan_f21_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__EvioEventDictLN_FADC_data_f13_t),sizeof(FADC_data_f13_t),-1,262144,(char*)NULL,G__setup_memvarFADC_data_f13_t,G__setup_memfuncFADC_data_f13_t);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlEFADC_chan_f13_tcOallocatorlEFADC_chan_f13_tgRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f13_tcOallocatorlEFADC_chan_f13_tgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__EvioEventDictLN_FADC_data_f15_t),sizeof(FADC_data_f15_t),-1,262144,(char*)NULL,G__setup_memvarFADC_data_f15_t,G__setup_memfuncFADC_data_f15_t);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlEFADC_chan_f15_tcOallocatorlEFADC_chan_f15_tgRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f15_tcOallocatorlEFADC_chan_f15_tgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__EvioEventDictLN_FADC_data_f21_t),sizeof(FADC_data_f21_t),-1,262144,(char*)NULL,G__setup_memvarFADC_data_f21_t,G__setup_memfuncFADC_data_f21_t);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlEFADC_chan_f21_tcOallocatorlEFADC_chan_f21_tgRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_chan_f21_tcOallocatorlEFADC_chan_f21_tgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__EvioEventDictLN_SVT_chan_t),sizeof(SVT_chan_t),-1,262144,(char*)NULL,G__setup_memvarSVT_chan_t,G__setup_memfuncSVT_chan_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__EvioEventDictLN_SVT_FPGA_t),sizeof(SVT_FPGA_t),-1,262144,(char*)NULL,G__setup_memvarSVT_FPGA_t,G__setup_memfuncSVT_FPGA_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__EvioEventDictLN_SSP_cluster_t),sizeof(SSP_cluster_t),-1,262144,(char*)NULL,G__setup_memvarSSP_cluster_t,G__setup_memfuncSSP_cluster_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__EvioEventDictLN_SSP_single_t),sizeof(SSP_single_t),-1,262144,(char*)NULL,G__setup_memvarSSP_single_t,G__setup_memfuncSSP_single_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__EvioEventDictLN_SSP_pair_t),sizeof(SSP_pair_t),-1,262144,(char*)NULL,G__setup_memvarSSP_pair_t,G__setup_memfuncSSP_pair_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__EvioEventDictLN_SSP_t),sizeof(SSP_t),-1,262144,(char*)NULL,G__setup_memvarSSP_t,G__setup_memfuncSSP_t);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlESSP_cluster_tcOallocatorlESSP_cluster_tgRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_cluster_tcOallocatorlESSP_cluster_tgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlESSP_single_tcOallocatorlESSP_single_tgRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_single_tcOallocatorlESSP_single_tgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlESSP_pair_tcOallocatorlESSP_pair_tgRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_reverse_iteratorlEvectorlESSP_pair_tcOallocatorlESSP_pair_tgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__EvioEventDictLN_EVIO_Event_t),sizeof(EVIO_Event_t),-1,262144,(char*)NULL,G__setup_memvarEVIO_Event_t,G__setup_memfuncEVIO_Event_t);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlEFADC_data_f13_tcOallocatorlEFADC_data_f13_tgRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f13_tcOallocatorlEFADC_data_f13_tgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlEFADC_data_f15_tcOallocatorlEFADC_data_f15_tgRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f15_tcOallocatorlEFADC_data_f15_tgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlEFADC_data_f21_tcOallocatorlEFADC_data_f21_tgRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_reverse_iteratorlEvectorlEFADC_data_f21_tcOallocatorlEFADC_data_f21_tgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_vectorlESVT_chan_tcOallocatorlESVT_chan_tgRsPgR);
   G__get_linked_tagnum_fwd(&G__EvioEventDictLN_reverse_iteratorlEvectorlESVT_chan_tcOallocatorlESVT_chan_tgRsPgRcLcLiteratorgR);
}
extern "C" void G__cpp_setupEvioEventDict(void) {
  G__check_setup_version(30051515,"G__cpp_setupEvioEventDict()");
  G__set_cpp_environmentEvioEventDict();
  G__cpp_setup_tagtableEvioEventDict();

  G__cpp_setup_inheritanceEvioEventDict();

  G__cpp_setup_typetableEvioEventDict();

  G__cpp_setup_memvarEvioEventDict();

  G__cpp_setup_memfuncEvioEventDict();
  G__cpp_setup_globalEvioEventDict();
  G__cpp_setup_funcEvioEventDict();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncEvioEventDict();
  return;
}
class G__cpp_setup_initEvioEventDict {
  public:
    G__cpp_setup_initEvioEventDict() { G__add_setup_func("EvioEventDict",(G__incsetup)(&G__cpp_setupEvioEventDict)); G__call_setup_funcs(); }
   ~G__cpp_setup_initEvioEventDict() { G__remove_setup_func("EvioEventDict"); }
};
G__cpp_setup_initEvioEventDict G__cpp_setup_initializerEvioEventDict;

